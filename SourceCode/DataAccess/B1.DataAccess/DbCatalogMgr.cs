using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Data;
using System.Data.Common;

using B1.Core;
using B1.ILoggingManagement;
using B1.CacheManagement;

namespace B1.DataAccess
{
    /// <summary>
    /// Contains the data attributes for a database table column 
    /// as found in the database's catalog.  It also contains
    /// a cross reference of DataTypes (between back-end specific
    /// and .Net and DataAccessApplicationBloock types)
    /// </summary>
    public struct DbColumnStructure
    {
        /// <summary>
        /// Name of column
        /// </summary>
        public string ColumnName;
        /// <summary>
        /// Schema of the table that the column belongs to
        /// </summary>
        public string SchemaName;
        /// <summary>
        /// Name of table that the column belongs to
        /// </summary>
        public string TableName;
        /// <summary>
        /// Schema + TableName that the column belongs to
        /// </summary>
        public string FullyQualifiedName { get { return SchemaName + "." + TableName + "." + ColumnName; } }
        /// <summary>
        /// The .Net framework dataType of the column
        /// </summary>
        public string DataTypeDotNet;
        /// <summary>
        /// The back-end database specific dataType of the column
        /// </summary>
        public string DataTypeNativeDb;
        /// <summary>
        /// DataColumn (of a DataTable) dataType of the column
        /// </summary>
        public string DataTypeDataColumn;
        /// <summary>
        /// DataAccess Application Block dataType of the column
        /// </summary>
        public DbType DataTypeGenericDb;
        /// <summary>
        /// Indicates if null is allowed for column value
        /// </summary>
        public bool IsNullable;
        /// <summary>
        /// Indicates if it is a computed column (SqlServer specific)
        /// </summary>
        public bool IsComputed;
        /// <summary>
        /// Indicates if the column has an autogenerated value (e.g. DateTime, Identity (SqlServer))
        /// </summary>
        public bool IsAutoGenerated;
        /// <summary>
        /// Indicates if the column has a database default value
        /// </summary>
        public bool HasDefault;
        /// <summary>
        /// The position that the column is within the table
        /// </summary>
        public Int16 Ordinal;
        /// <summary>
        /// Used to set the maximum length of character columns
        /// </summary>
        public Int32 MaxLength;
        /// <summary>
        /// Number of digits to left of decimal (radix) point
        /// </summary>
        public Int16 Precision;
        /// <summary>
        /// decimal point
        /// </summary>
        public Int16 Radix;
        /// <summary>
        /// Number of digits to the right of the decimal (radix) point
        /// </summary>
        public Int16 Scale;
        /// <summary>
        /// Value of the column
        /// </summary>
        public object Value;
    }

    /// <summary>
    /// Contains the meta data regarding table indexes
    /// </summary>
    public struct DbIndexStructure
    {
        /// <summary>
        /// Name of the index
        /// </summary>
        public string IndexName;
        /// <summary>
        /// Schema of the table that the index belongs to
        /// </summary>
        public string SchemaName;
        /// <summary>
        /// Name of table that the index belongs to
        /// </summary>
        public string TableName;
        /// <summary>
        /// SchemaName.TableName.IndexName
        /// </summary>
        public string FullyQualifiedName { get { return SchemaName + "." + TableName + "." + IndexName; } }
        /// <summary>
        /// Indicates if the index is a unqique index
        /// </summary>
        public bool IsUnique;
        /// <summary>
        /// Indicates if the index is the primary key
        /// </summary>
        public bool IsPrimaryKey;
        /// <summary>
        /// The ordered list of columns defining the index
        /// </summary>
        public SortedDictionary<Int16, DbIndexColumnStructure> Columns;

        /// <summary>
        /// Constructor to provide a thread safe copy of the 
        /// given structure with all its contained collections.
        /// </summary>
        /// <param name="dbIndex">DbIndexStructure to copy</param>
        public DbIndexStructure (DbIndexStructure dbIndex)
        {
            IndexName = dbIndex.IndexName;
            SchemaName = dbIndex.SchemaName;
            TableName = dbIndex.TableName;
            IsUnique = dbIndex.IsUnique;
            IsPrimaryKey = dbIndex.IsPrimaryKey;
            Columns = new SortedDictionary<short, DbIndexColumnStructure>(dbIndex.Columns);
        }
    }


    /// <summary>
    /// Contains the meta data regarding table foreign keys
    /// </summary>
    public struct DbForeignKeyStructure
    {
        /// <summary>
        /// Name of the Constraint
        /// </summary>
        public string ForeignKeyName;
        /// <summary>
        /// The schema of the referenced table
        /// </summary>
        public string SchemaName;
        /// <summary>
        /// The name of the referenced table
        /// </summary>
        public string TableName;
        /// <summary>
        /// SchemaName.TableName.ForeignKeyName
        /// </summary>
        public string FullyQualifiedName { get { return SchemaName + "." + TableName + "." + ForeignKeyName; } }
        /// <summary>
        /// The ordered list of columns defining the constraint
        /// where the key is the ordinal within the key and the value is the columnName
        /// </summary>
        public SortedDictionary<Int16, string> KeyOrder;
        /// <summary>
        /// The collection of base column to referenced column relationships
        /// </summary>
        public Dictionary<string, string> KeyColumns;

        /// <summary>
        /// Constructor to provide a thread safe copy of the 
        /// given structure with all its contained collections.
        /// </summary>
        /// <param name="dbForeignKey">DbForeignKeyStructure to copy</param>
        public DbForeignKeyStructure(DbForeignKeyStructure dbForeignKey)
        {
            ForeignKeyName = dbForeignKey.ForeignKeyName;
            SchemaName = dbForeignKey.SchemaName;
            TableName = dbForeignKey.TableName;
            KeyOrder = new SortedDictionary<short,string>(dbForeignKey.KeyOrder);
            KeyColumns = new Dictionary<string,string>(dbForeignKey.KeyColumns, StringComparer.CurrentCultureIgnoreCase);
        }
    }

    
    #pragma warning disable 1591 // disable the xmlComments warning
    public class DbQualifiedObject<T>
    {
        string _alias = null;
        public string Alias { get { return _alias; } }
        public string SchemaName { get; set; }
        public string TableName { get; set; }
        public T DbObject { get; set; }

        public DbQualifiedObject(string schemaName, string tableName, T dbObject)
            : this(schemaName, tableName, null, dbObject)
        {
        }

        public DbQualifiedObject(string schemaName, string tableName, string alias, T dbObject)
        {
            SchemaName = schemaName;
            TableName = tableName;
            DbObject = dbObject;
            _alias = !string.IsNullOrEmpty(alias) ? alias : null;
        }

        public override int GetHashCode()
        {
            return ToString().GetHashCode();
        }

        public override bool Equals(object obj)
        {
            return this == (DbQualifiedObject<T>)obj;
        }

        public override string ToString()
        {
            return String.Format("{0}.{1}", !string.IsNullOrEmpty(_alias) ? _alias 
                : SchemaName + "." + TableName, DbObject.ToString());
        }

        public static bool operator ==(DbQualifiedObject<T> l, DbQualifiedObject<T> r) 
        {
            return r.ToString().ToLower() == l.ToString().ToLower();
        }

        public static bool operator !=(DbQualifiedObject<T> l, DbQualifiedObject<T> r) 
        {
            return !(r == l);
        }
    }
    #pragma warning restore 1591 // disable the xmlComments warning
       
    /// <summary>
    /// Contains the meta data regarding tables
    /// </summary>
    public struct DbTableStructure
    {
        /// <summary>
        /// Name of the table
        /// </summary>
        public string TableName;
        /// <summary>
        /// Schema name
        /// </summary>
        public string SchemaName;
        /// <summary>
        /// SchemaName + "." + TableName
        /// </summary>
        public string FullyQualifiedName { get { return SchemaName + "." + TableName; } }
        /// <summary>
        /// An ordered list of the columns that belong to the table
        /// where the Key is the Ordinal and the Value is the ColumnName
        /// </summary>
        public SortedDictionary<Int16, string> Row;
        /// <summary>
        /// A collection of the table's columns
        /// where the key is the ColumnName and the Value is the Ordinal
        /// </summary>
        public Dictionary<string, Int16> Columns;
        /// <summary>
        /// A collection of the primary key columns (not ordered)
        /// Where the key is the ColumnName and the Value is the position within the index
        /// </summary>
        public Dictionary<string, byte> PrimaryKeyColumns;
        /// <summary>
        /// An ordered list of the primary key columns
        /// where the key is the position with the index and the value is the ColumnName
        /// </summary>
        public SortedDictionary<byte, string> PrimaryKey;
        /// <summary>
        /// An ordered list of the indexes(and their columns) on the table
        /// where the key is the index name and the value contains the index meta data
        /// </summary>
        public Dictionary<string, DbIndexStructure> Indexes;
        /// <summary>
        /// The collection of foreign keys on the table (if any)
        /// Where the key is the name of the key and the value contains the key meta data
        /// </summary>
        public Dictionary<string, DbForeignKeyStructure> ForeignKeys;

        /// <summary>
        /// Constructor to provide a thread safe copy of the 
        /// given structure with all its contained collections.
        /// </summary>
        /// <param name="dbTable">DbTableStructure to copy</param>
        public DbTableStructure(DbTableStructure dbTable)
        {
            TableName = dbTable.TableName;
            SchemaName = dbTable.SchemaName;
            Row = new SortedDictionary<short, string>(dbTable.Row);                
            Columns = new Dictionary<string, short>(dbTable.Columns, StringComparer.CurrentCultureIgnoreCase);           
            PrimaryKeyColumns = new Dictionary<string, byte>(dbTable.PrimaryKeyColumns, StringComparer.CurrentCultureIgnoreCase);          
            PrimaryKey = new SortedDictionary<byte, string>(dbTable.PrimaryKey);
            Indexes = dbTable.Indexes.ToDictionary(kvp => kvp.Key, kvp => new DbIndexStructure(kvp.Value)
                    , StringComparer.CurrentCultureIgnoreCase);
            ForeignKeys = dbTable.ForeignKeys.ToDictionary(kvp => kvp.Key, kvp => new DbForeignKeyStructure(kvp.Value)
                    , StringComparer.CurrentCultureIgnoreCase); 
        }
    }

    /// <summary>
    /// Enumerations of comparison operators used in where clauses or joins
    /// </summary>
#pragma warning disable 1591 // disable the xmlComments warning
    public enum ComparisonOperatorEnum { Equals, Greater, Less, GreaterEquals, LessEquals, NotEquals, Between, NotBetween, In, NotIn }
#pragma warning restore 1591 // restore the xmlComments warning

    /// <summary>
    /// Contains meta data about comparison operations to be used in dynamic sql
    /// in where clauses (e.g. in or >=, etc) or joins
    /// </summary>
    public struct DbComparisonOperatorStructure
    {
        /// <summary>
        /// Comparison operation enumerator (e.g. Equals, Greater, LessThan, etc)
        /// </summary>
        public ComparisonOperatorEnum OperatorEnum;
        /// <summary>
        /// Returns the SQL compliant string representation of the enumerations
        /// </summary>
        public string OperatorString
        {
            get
            {
                switch (OperatorEnum)
                {
                    case ComparisonOperatorEnum.In:
                        return "in";
                    case ComparisonOperatorEnum.NotIn:
                        return "not in";
                    case ComparisonOperatorEnum.Between:
                        return "between";
                    case ComparisonOperatorEnum.NotBetween:
                        return "not between";
                    case ComparisonOperatorEnum.Less:
                        return "<";
                    case ComparisonOperatorEnum.LessEquals:
                        return "<=";
                    case ComparisonOperatorEnum.Greater:
                        return ">";
                    case ComparisonOperatorEnum.GreaterEquals:
                        return ">=";
                    case ComparisonOperatorEnum.NotEquals:
                        return "<>";
                    default:
                        return "=";
                };
            }
        }
        /// <summary>
        /// Ordered set of operator values which can be a set of bind variables or constants
        /// for example as used in an IN clause
        /// </summary>
        public List<DbBindVariableStructure> OperatorValues;
        /// <summary>
        /// If true will cause a SQL compliant check for null in the comparison 
        /// </summary>
        public bool IncludeNullCheck;
    }

    /// <summary>
    /// Metadata about columns used in indexes. 
    /// </summary>
    public struct DbIndexColumnStructure
    {
        /// <summary>
        /// The column's name
        /// </summary>
        public string ColumnName;
        /// <summary>
        /// Used for functional based indexes
        /// </summary>
        public string ColumnFunction;
        /// <summary>
        /// Indicates if the column is sorted descending
        /// </summary>
        public bool IsDescending;
    }

    /// <summary>
    /// Metadata about a bind value to be used in dynamic sql to set a column
    /// </summary>
    public struct DbBindVariableStructure
    {
        /// <summary>
        /// Contains the string used by the application programmer to refer
        /// to a particular value;  A parameter will be created for that
        /// variable only if the Column is provided for type definition.
        /// Otherwise, the programmer will need to define a parameter
        /// after the DbCommand is created.
        /// </summary>
        public string VariableOrConst;
        /// <summary>
        /// The optional column name if a bind variable is associated with
        /// a column, then it's type can be derived automatically.
        /// </summary>
        public string BindToColumnType;
    }

    /// <summary>
    /// Contains meta data for generating back-end specific function calls
    /// in dynamic sql.
    /// </summary>
    public struct DbFunctionStructure
    {
        /// <summary>
        /// Indicates that the column has an autogenerated value and
        /// nothing needs to be set.
        /// </summary>
        public bool AutoGenerate;
        /// <summary>
        /// Provides the back-end specific function syntax to be used
        /// to set the value of a column.
        /// </summary>
        public string FunctionBody;
    }

    /// <summary>
    /// Maintains a cache of database catalog information about tables
    /// which can be used for generating dynamic sql.
    /// </summary>
    internal class DbCatalogMgr
    {
        private DataAccessMgr _daMgr = null;
        CacheMgr<DbColumnStructure> _columnCache = new CacheMgr<DbColumnStructure>(StringComparer.CurrentCultureIgnoreCase);
        CacheMgr<DbTableStructure> _tableCache = new CacheMgr<DbTableStructure>(StringComparer.CurrentCultureIgnoreCase);
        
        enum EnumTableAttributes
        {
            SchemaName, SchemaId, TableName, TableId, Hierarchy, ReconciledDate,
            Description
        };

        enum EnumColumnAttributes
        {
            SchemaName, TableName, TableId, ColumnId, ColumnName, DataType, ReconciledDate,
            Description, OrdinalPosition, ColumnDefault, IsNullable, IsIdentity,
            IsComputed, CharacterMaximumLength, NumericPrecision, NumericPrecisionRadix,
            NumericScale, DateTimePrecision
        };

        /// <summary>
        /// Database Catalog Cache of Database Objects (Tables, Columns, PrimaryKeys)
        /// Cache will the lazily initialized as requests for objects are made
        /// </summary>
        /// <param name="dbMgr"></param>
        internal DbCatalogMgr(DataAccessMgr dbMgr)
        {
            _daMgr = dbMgr;
            // Build the DbCommandCache
            LoadDbCommandCache();
        }

        internal void ClearCache()
        {
            _columnCache.Clear();
            _tableCache.Clear();
        }

        /// <summary>
        /// Build the dbCommands and add them to the cache.
        /// </summary>
        void LoadDbCommandCache()
        {
            DbCommand dbCmd = GetCatalogColumnsCmd();
            _daMgr.InternalDbCmdCache.Add(Constants.USP_CatalogGetColumns, dbCmd);

            dbCmd = GetCatalogPrimaryKeysCmd();
            _daMgr.InternalDbCmdCache.Add(Constants.USP_CatalogGetPrimaryKeys, dbCmd);

            dbCmd = GetCatalogIndexesCmd(); 
            _daMgr.InternalDbCmdCache.Add(Constants.USP_CatalogGetIndexes, dbCmd);

            dbCmd = GetCatalogForeignKeysCmd(); 
            _daMgr.InternalDbCmdCache.Add(Constants.USP_CatalogGetForeignKeys, dbCmd);
        }

        DbCommand GetCatalogColumnsCmd()
        {
            DbParameter paramSchemaName = _daMgr.CreateParameter(Constants.SchemaName
                    , DbType.String, null, 0, ParameterDirection.Input, null);

            DbParameter paramTableName = _daMgr.CreateParameter(Constants.TableName
                    , DbType.String, null, 0, ParameterDirection.Input, null);

            switch (_daMgr.DatabaseType)
            {
                case DataAccessMgr.EnumDbType.SqlServer:
                    {
                        DbTableDmlMgr joinSelect = new DbTableDmlMgr(Constants.Tables
                                , Constants.Sys
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Name, Constants.TableName));

                        joinSelect.AddJoin(Constants.Schemas, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Schemas, Constants.Schema_Id)
                                    == j.Column(Constants.Tables, Constants.Schema_Id)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.SchemaName));

                        joinSelect.AddJoin(Constants.Columns, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Sys, Constants.Columns, Constants.Object_Id)
                                    == j.Column(Constants.Sys, Constants.Tables, Constants.Object_Id)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.ColumnName)
                                    , joinSelect.ColumnsAs(Constants.Column_Id, Constants.OrdinalPosition)
                                    , joinSelect.ColumnsAs(Constants.Is_RowGuidCol, Constants.IsRowGuidCol)
                                    , joinSelect.ColumnsAs(Constants.Is_Computed, Constants.IsComputed)
                                    , joinSelect.ColumnsAs(Constants.Is_Identity, Constants.IsIdentity));

                        string tAlias = joinSelect.AddJoin(Constants.Columns, Constants.Information_Schema, DbTableJoinType.Inner,
                                (j) => j.Column(Constants.Information_Schema, Constants.Columns, Constants.Table_Schema)
                                    == j.Column(Constants.Sys, Constants.Schemas, Constants.Name)
                                && j.Column(Constants.Information_Schema, Constants.Columns, Constants.Table_Name)
                                    == j.Column(Constants.Sys, Constants.Tables, Constants.Name)
                                && j.Column(Constants.Information_Schema, Constants.Columns, Constants.Column_Name)
                                    == j.Column(Constants.Sys, Constants.Columns, Constants.Name)
                                    , joinSelect.ColumnsAs(Constants.Data_Type, Constants.DataType)
                                    , joinSelect.ColumnsAs(Constants.Column_Default, Constants.ColumnDefault)
                                    , joinSelect.ColumnsAs(Constants.Character_Mximum_Length, Constants.CharacterMaximumLength)
                                    , joinSelect.ColumnsAs(Constants.Numeric_Precision, Constants.NumericPrecision)
                                    , joinSelect.ColumnsAs(Constants.Numeric_Precision_Radix, Constants.NumericPrecisionRadix)
                                    , joinSelect.ColumnsAs(Constants.Numeric_Scale, Constants.NumericScale)
                                    , joinSelect.ColumnsAs(Constants.DataTime_Precision, Constants.DataTimePrecision));

                        joinSelect.AddCaseColumn("0", Constants.IsNullable,
                                joinSelect.When(t => t.AliasedColumn(tAlias, Constants.Is_Nullable) == "yes", "1"));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.Sys, Constants.Schemas, Constants.Name)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.Sys, Constants.Tables, Constants.Name)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.Schemas
                                , _daMgr.BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.Tables
                                , _daMgr.BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.Columns
                                , _daMgr.BuildIndexColumnAscending(Constants.Column_Id)));

                        // build the dbCommand
                        DbCommand dbCmd = _daMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                 case DataAccessMgr.EnumDbType.Oracle:
                    {
                        DbTableDmlMgr joinSelect = new DbTableDmlMgr(Constants.All_Tab_Columns
                                , Constants.Sys
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Owner, Constants.SchemaName)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Data_Type, Constants.DataType)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Data_Default, Constants.ColumnDefault)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Char_Length, Constants.CharacterMaximumLength)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Data_Precision, Constants.NumericPrecision)
                                , new DbConstValue(DbTableDmlMgr.SelectColumnsAs("null", Constants.NumericPrecisionRadix))
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Data_Scale, Constants.NumericScale)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Data_Length, Constants.DataTimePrecision)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Data_Length, Constants.Data_Length)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Column_Name, Constants.ColumnName)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Column_Id, Constants.OrdinalPosition)
                                , new DbConstValue(DbTableDmlMgr.SelectColumnsAs("0", Constants.IsRowGuidCol))
                                , new DbConstValue(DbTableDmlMgr.SelectColumnsAs("0", Constants.IsComputed))
                                , new DbConstValue(DbTableDmlMgr.SelectColumnsAs("0", Constants.IsIdentity))
                                , new DbConstValue(DbTableDmlMgr.SelectColumnsAs(Constants.Table_Name, Constants.TableName)));


                        joinSelect.AddCaseColumn("0", Constants.IsNullable,
                                joinSelect.When(t => t.Column(Constants.All_Tab_Columns, Constants.Nullable) == "Y", "1"));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.Sys, Constants.All_Tab_Columns, Constants.Owner)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.Sys, Constants.All_Tab_Columns, Constants.Table_Name)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.All_Tab_Columns
                                , _daMgr.BuildIndexColumnAscending(Constants.Owner)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.All_Tab_Columns
                                , _daMgr.BuildIndexColumnAscending(Constants.Table_Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.All_Tab_Columns
                                , _daMgr.BuildIndexColumnAscending(Constants.Column_Id)));

                        // build the dbCommand
                        DbCommand dbCmd = _daMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                case DataAccessMgr.EnumDbType.Db2:
                    {
                        // base table
                        DbTableDmlMgr joinSelect = new DbTableDmlMgr(Constants.Columns
                                , Constants.SysIbm
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Table_Name, Constants.TableName)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Column_Name, Constants.ColumnName)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Ordinal_Position, Constants.OrdinalPosition)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Column_Default, Constants.ColumnDefault)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Character_Mximum_Length
                                    , Constants.CharacterMaximumLength)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Numeric_Precision, Constants.NumericPrecision)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Numeric_Precision_Radix
                                    , Constants.NumericPrecisionRadix)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Numeric_Scale, Constants.NumericScale)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.DataTime_Precision
                                    , Constants.DataTimePrecision)
                                , new DbConstValue(DbTableDmlMgr.SelectColumnsAs("0", Constants.IsRowGuidCol))
                                , new DbConstValue(DbTableDmlMgr.SelectColumnsAs("0", Constants.IsComputed)));

                        string tAlias = joinSelect.AddJoin(Constants.SQLColumns, Constants.SysIbm, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.SQLColumns, Constants.Column_Name)
                                    == j.Column(Constants.Columns, Constants.Column_Name)
                                    && j.Column(Constants.SQLColumns, Constants.Table_Name)
                                    == j.Column(Constants.Columns, Constants.Table_Name)
                                    && j.Column(Constants.SQLColumns, Constants.Table_Schem)
                                    == j.Column(Constants.Columns, Constants.Table_Schema)
                                        , joinSelect.ColumnsAs(Constants.Table_Schem, Constants.SchemaName)
                                        , joinSelect.ColumnsAs(Constants.Type_Name, Constants.DataType)
                                        , joinSelect.ColumnsAs(Constants.Nullable, Constants.IsNullable));

                        joinSelect.AddCaseColumn("0", Constants.IsIdentity,
                                joinSelect.When(t => t.AliasedColumn(tAlias, Constants.Pseudo_Column) == 2, "1"));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.SysIbm, Constants.SQLColumns
                                    , Constants.Table_Schem)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.SysIbm, Constants.Columns, Constants.Table_Name)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumnStructure>(Constants.SysIbm
                                , Constants.SQLColumns
                                , _daMgr.BuildIndexColumnAscending(Constants.Table_Schem)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumnStructure>(Constants.SysIbm
                                , Constants.Columns
                                , _daMgr.BuildIndexColumnAscending(Constants.Table_Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumnStructure>(Constants.SysIbm
                                , Constants.Columns
                                , _daMgr.BuildIndexColumnAscending(Constants.Ordinal_Position)));

                        // build the dbCommand
                        DbCommand dbCmd = _daMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                default:
                    throw new ExceptionEvent(enumExceptionEventCodes.FunctionNotImplementedForDbType
                                    , _daMgr.DatabaseType.ToString());
            }
        }

        DbCommand GetCatalogPrimaryKeysCmd()
        {
            DbParameter paramSchemaName = _daMgr.CreateParameter(Constants.SchemaName
                    , DbType.String, null, 0, ParameterDirection.Input, null);

            DbParameter paramTableName = _daMgr.CreateParameter(Constants.TableName
                    , DbType.String, null, 0, ParameterDirection.Input, null);

            switch (_daMgr.DatabaseType)
            {
                case DataAccessMgr.EnumDbType.SqlServer:
                    {
                        DbTableDmlMgr joinSelect = new DbTableDmlMgr(Constants.Indexes
                                , Constants.Sys
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Name, Constants.PrimaryKeyName));

                        joinSelect.AddJoin(Constants.Index_Columns, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Index_Columns, Constants.Object_Id)
                                    == j.Column(Constants.Indexes, Constants.Object_Id)
                                    && j.Column(Constants.Index_Columns, Constants.Index_Id)
                                    == j.Column(Constants.Indexes, Constants.Index_Id)
                                    && j.Column(Constants.Indexes, Constants.Is_Primary_Key)
                                    == 1 
                                    , joinSelect.ColumnsAs(Constants.Is_Descending_Key, Constants.IsDescend)
                                    , joinSelect.ColumnsAs(Constants.Key_Ordinal, Constants.Ordinal));

                        string c = joinSelect.AddJoin(Constants.SysColumns, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.SysColumns, Constants.Id)
                                    == j.Column(Constants.Indexes, Constants.Object_Id)
                                    && j.Column(Constants.Index_Columns, Constants.Column_Id)
                                    == j.Column(Constants.SysColumns, Constants.ColId)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.ColumnName));

                        string t = joinSelect.AddJoin(Constants.Objects, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Objects, Constants.Object_Id)
                                    == j.Column(Constants.Indexes, Constants.Object_Id)
                                    && j.Column(Constants.Objects, Constants.Type)
                                    == "U"
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.TableName));

                        string s = joinSelect.AddJoin(Constants.Schemas, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Objects, Constants.Schema_Id)
                                    == j.Column(Constants.Schemas, Constants.Schema_Id)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.SchemaName));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.Sys, Constants.Schemas
                                    , Constants.Name)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.Sys
                                    , Constants.Objects, Constants.Name)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumnStructure>(
                                Constants.Sys
                                , Constants.Schemas
                                , _daMgr.BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumnStructure>(
                                Constants.Sys
                                , Constants.Objects
                                , _daMgr.BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumnStructure>(
                                Constants.Sys
                                , Constants.Indexes
                                , _daMgr.BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(4, new DbQualifiedObject<DbIndexColumnStructure>(
                                Constants.Sys
                                , Constants.Index_Columns
                                , _daMgr.BuildIndexColumnAscending(Constants.Key_Ordinal)));

                        // build the dbCommand
                        DbCommand dbCmd = _daMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                case DataAccessMgr.EnumDbType.Oracle:
                    {
                        DbTableDmlMgr joinSelect = new DbTableDmlMgr(Constants.All_Indexes
                                , Constants.Sys
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Owner, Constants.SchemaName)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Index_Name, Constants.PrimaryKeyName));

                        joinSelect.AddJoin(Constants.All_Ind_Columns, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.All_Indexes, Constants.Owner)
                                    == j.Column(Constants.All_Ind_Columns, Constants.Index_Owner)
                                    && j.Column(Constants.All_Indexes, Constants.Index_Name)
                                    == j.Column(Constants.All_Ind_Columns, Constants.Index_Name)
                                    , joinSelect.ColumnsAs(Constants.Table_Name, Constants.TableName)
                                    , joinSelect.ColumnsAs(Constants.Column_Name, Constants.ColumnName)
                                    , joinSelect.ColumnsAs(Constants.Column_Position, Constants.Ordinal));

                        joinSelect.AddCaseColumn("0", Constants.IsDescend,
                                joinSelect.When(t => t.Column(Constants.All_Ind_Columns, Constants.Descend) == "DESC", "1"));

                        joinSelect.AddJoin(Constants.All_Constraints, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.All_Indexes, Constants.Owner)
                                    == j.Column(Constants.All_Constraints, Constants.Owner)
                                    && j.Column(Constants.All_Indexes, Constants.Index_Name)
                                    == j.Column(Constants.All_Constraints, Constants.Constraint_Name));

                        joinSelect.AddCaseColumn("0", Constants.IsPrimaryKey,
                                joinSelect.When(t => t.Column(Constants.All_Constraints, Constants.Constraint_Type) == "P", "1"));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.Sys, Constants.All_Indexes, Constants.Owner)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.Sys, Constants.All_Ind_Columns, Constants.Table_Name)
                                    == paramTableName)
                                && j.Column(Constants.Sys, Constants.All_Constraints, Constants.Constraint_Type)
                                    == "P");

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.All_Indexes
                                , _daMgr.BuildIndexColumnAscending(Constants.Owner)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.All_Ind_Columns
                                , _daMgr.BuildIndexColumnAscending(Constants.Table_Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.All_Indexes
                                , _daMgr.BuildIndexColumnAscending(Constants.Index_Name)));

                        joinSelect.OrderByColumns.Add(4, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.All_Ind_Columns
                                , _daMgr.BuildIndexColumnAscending(Constants.Column_Position)));

                        // build the dbCommand
                        DbCommand dbCmd = _daMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                case DataAccessMgr.EnumDbType.Db2:
                    {
                         // base table
                        DbTableDmlMgr joinSelect = new DbTableDmlMgr(Constants.Indexes
                                , Constants.SysCat
                                , DbTableDmlMgr.SelectColumnsAs(Constants.IndSchema, Constants.SchemaName)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.TabName, Constants.TableName)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.IndName, Constants.PrimaryKeyName));

                        string tAlias = joinSelect.AddJoin(Constants.IndexColUse, Constants.SysCat, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Indexes, Constants.IndSchema)
                                    == j.Column(Constants.IndexColUse, Constants.IndSchema)
                                    && j.Column(Constants.Indexes, Constants.IndName)
                                    == j.Column(Constants.IndexColUse, Constants.IndName)
                                        , joinSelect.ColumnsAs(Constants.ColName, Constants.ColumnName)
                                        , joinSelect.ColumnsAs(Constants.ColSeq, Constants.Ordinal));

                        joinSelect.AddCaseColumn("1", Constants.IsDescend,
                                joinSelect.When(t => t.AliasedColumn(tAlias
                                        , Constants.ColOrder) == "A", "0"));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.SysCat, Constants.Indexes
                                , Constants.IndSchema)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.SysCat, Constants.Indexes
                                , Constants.TabName)
                                    == paramTableName)
                                && j.Column(Constants.Indexes, Constants.UniqueRule) == "P");

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumnStructure>(Constants.SysCat
                                , Constants.Indexes
                                , _daMgr.BuildIndexColumnAscending(Constants.IndSchema)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumnStructure>(Constants.SysCat
                                , Constants.Indexes
                                , _daMgr.BuildIndexColumnAscending(Constants.TabName)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumnStructure>(Constants.SysCat
                                , Constants.Indexes
                                , _daMgr.BuildIndexColumnAscending(Constants.IndName)));

                        joinSelect.OrderByColumns.Add(4, new DbQualifiedObject<DbIndexColumnStructure>(Constants.SysCat
                                , Constants.IndexColUse
                                , _daMgr.BuildIndexColumnAscending(Constants.ColSeq)));
                        // build the dbCommand
                        DbCommand dbCmd = _daMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                default:
                    throw new ExceptionEvent(enumExceptionEventCodes.FunctionNotImplementedForDbType
                                    , _daMgr.DatabaseType.ToString());
            }
        }

        DbCommand GetCatalogIndexesCmd()
        {
            DbParameter paramSchemaName = _daMgr.CreateParameter(Constants.SchemaName
                    , DbType.String, null, 0, ParameterDirection.Input, null);

            DbParameter paramTableName = _daMgr.CreateParameter(Constants.TableName
                    , DbType.String, null, 0, ParameterDirection.Input, null);

            switch (_daMgr.DatabaseType)
            {
                case DataAccessMgr.EnumDbType.SqlServer:
                    {
                        DbTableDmlMgr joinSelect = new DbTableDmlMgr(Constants.Indexes
                                , Constants.Sys
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Name, Constants.IndexName)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Is_Unique, Constants.IsUnique)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Is_Primary_Key, Constants.IsPrimaryKey)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Type_Desc, Constants.TypeDescription)
                                , new DbConstValue(DbTableDmlMgr.SelectColumnsAs("null", Constants.ColumnFunction)));

                        joinSelect.AddJoin(Constants.Index_Columns, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Index_Columns, Constants.Object_Id)
                                    == j.Column(Constants.Indexes, Constants.Object_Id)
                                    && j.Column(Constants.Index_Columns, Constants.Index_Id)
                                    == j.Column(Constants.Indexes, Constants.Index_Id)
                                    , joinSelect.ColumnsAs(Constants.Is_Descending_Key, Constants.IsDescend)
                                    , joinSelect.ColumnsAs(Constants.Key_Ordinal, Constants.Ordinal));

                        string c = joinSelect.AddJoin(Constants.SysColumns, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.SysColumns, Constants.Id)
                                    == j.Column(Constants.Indexes, Constants.Object_Id)
                                    && j.Column(Constants.Index_Columns, Constants.Column_Id)
                                    == j.Column(Constants.SysColumns, Constants.ColId)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.ColumnName));

                        string t = joinSelect.AddJoin(Constants.Objects, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Objects, Constants.Object_Id)
                                    == j.Column(Constants.Indexes, Constants.Object_Id)
                                    && j.Column(Constants.Objects, Constants.Type)
                                    == "U"
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.TableName));

                        string s = joinSelect.AddJoin(Constants.Schemas, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Objects, Constants.Schema_Id)
                                    == j.Column(Constants.Schemas, Constants.Schema_Id)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.SchemaName));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.Sys, Constants.Schemas
                                    , Constants.Name)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.Sys
                                    , Constants.Objects, Constants.Name)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumnStructure>(
                                Constants.Sys
                                , Constants.Schemas
                                , _daMgr.BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumnStructure>(
                                Constants.Sys
                                , Constants.Objects
                                , _daMgr.BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumnStructure>(
                                Constants.Sys
                                , Constants.Indexes
                                , _daMgr.BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(4, new DbQualifiedObject<DbIndexColumnStructure>(
                                Constants.Sys
                                , Constants.Index_Columns
                                , _daMgr.BuildIndexColumnAscending(Constants.Key_Ordinal)));

                        // build the dbCommand
                        DbCommand dbCmd = _daMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                case DataAccessMgr.EnumDbType.Oracle:
                    {
                        DbTableDmlMgr joinSelect = new DbTableDmlMgr(Constants.All_Indexes
                                , Constants.Sys
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Owner, Constants.SchemaName)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Index_Name, Constants.IndexName));

                        joinSelect.AddCaseColumn("0", Constants.IsUnique,
                                joinSelect.When(t => t.AliasedColumn(joinSelect.MainTable.TableAlias
                                        , Constants.Uniqueness) == "UNIQUE", "1"));

                        joinSelect.AddJoin(Constants.All_Ind_Columns, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.All_Indexes, Constants.Owner)
                                    == j.Column(Constants.All_Ind_Columns, Constants.Index_Owner)
                                    && j.Column(Constants.All_Indexes, Constants.Index_Name)
                                    == j.Column(Constants.All_Ind_Columns, Constants.Index_Name)
                                    , joinSelect.ColumnsAs(Constants.Table_Name, Constants.TableName)
                                    , joinSelect.ColumnsAs(Constants.Column_Name, Constants.ColumnName)
                                    , joinSelect.ColumnsAs(Constants.Column_Position, Constants.Ordinal));

                        joinSelect.AddCaseColumn("0", Constants.IsDescend,
                                joinSelect.When(t => t.Column(Constants.All_Ind_Columns, Constants.Descend) == "DESC", "1"));

                        joinSelect.AddJoin(Constants.All_Ind_Expressions, Constants.Sys, DbTableJoinType.LeftOuter
                                , (j) => j.Column(Constants.All_Indexes, Constants.Owner)
                                    == j.Column(Constants.All_Ind_Expressions, Constants.Index_Owner)
                                    && j.Column(Constants.All_Indexes, Constants.Index_Name)
                                    == j.Column(Constants.All_Ind_Expressions, Constants.Index_Name)
                                    && j.Column(Constants.All_Ind_Columns, Constants.Column_Position)
                                    == j.Column(Constants.All_Ind_Expressions, Constants.Column_Position)
                                    , joinSelect.ColumnsAs(Constants.Column_Expression, Constants.ColumnFunction));

                        joinSelect.AddJoin(Constants.All_Constraints, Constants.Sys, DbTableJoinType.LeftOuter
                                , (j) => j.Column(Constants.All_Indexes, Constants.Owner)
                                    == j.Column(Constants.All_Constraints, Constants.Owner)
                                    && j.Column(Constants.All_Indexes, Constants.Index_Name)
                                    == j.Column(Constants.All_Constraints, Constants.Constraint_Name));

                        joinSelect.AddCaseColumn("0", Constants.IsPrimaryKey,
                                joinSelect.When(t => t.Column(Constants.All_Constraints, Constants.Constraint_Type) == "P", "1"));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.Sys, Constants.All_Indexes, Constants.Owner)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.Sys, Constants.All_Ind_Columns, Constants.Table_Name)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.All_Indexes
                                , _daMgr.BuildIndexColumnAscending(Constants.Owner)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.All_Ind_Columns
                                , _daMgr.BuildIndexColumnAscending(Constants.Table_Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.All_Indexes
                                , _daMgr.BuildIndexColumnAscending(Constants.Index_Name)));

                        joinSelect.OrderByColumns.Add(4, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.All_Ind_Columns
                                , _daMgr.BuildIndexColumnAscending(Constants.Column_Position)));

                        // build the dbCommand
                        DbCommand dbCmd = _daMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                case DataAccessMgr.EnumDbType.Db2:
                    {
                         // base table
                        DbTableDmlMgr joinSelect = new DbTableDmlMgr(Constants.Indexes
                                , Constants.SysCat
                                , DbTableDmlMgr.SelectColumnsAs(Constants.IndSchema, Constants.SchemaName)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.TabName, Constants.TableName)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.IndName, Constants.IndexName)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.IndexType, Constants.TypeDescription)
                                , new DbConstValue(DbTableDmlMgr.SelectColumnsAs("null", Constants.ColumnFunction)));

                        joinSelect.AddCaseColumn("0", Constants.IsUnique,
                                joinSelect.When(t => t.AliasedColumn(joinSelect.MainTable.TableAlias
                                        , Constants.UniqueRule) == "P", "1"),
                                joinSelect.When(t => t.AliasedColumn(joinSelect.MainTable.TableAlias
                                        , Constants.UniqueRule) == "U", "1"));

                        joinSelect.AddCaseColumn("0", Constants.IsPrimaryKey,
                                joinSelect.When(t => t.AliasedColumn(joinSelect.MainTable.TableAlias
                                        , Constants.UniqueRule) == "P", "1"));

                        string tAlias = joinSelect.AddJoin(Constants.IndexColUse, Constants.SysCat, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Indexes, Constants.IndSchema)
                                    == j.Column(Constants.IndexColUse, Constants.IndSchema)
                                    && j.Column(Constants.Indexes, Constants.IndName)
                                    == j.Column(Constants.IndexColUse, Constants.IndName)
                                        , joinSelect.ColumnsAs(Constants.ColName, Constants.ColumnName)
                                        , joinSelect.ColumnsAs(Constants.ColSeq, Constants.Ordinal));

                        joinSelect.AddCaseColumn("1", Constants.IsDescend,
                                joinSelect.When(t => t.AliasedColumn(tAlias
                                        , Constants.ColOrder) == "A", "0"));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.SysCat, Constants.Indexes
                                , Constants.IndSchema)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.SysCat, Constants.Indexes
                                , Constants.TabName)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumnStructure>(Constants.SysCat
                                , Constants.Indexes
                                , _daMgr.BuildIndexColumnAscending(Constants.IndSchema)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumnStructure>(Constants.SysCat
                                , Constants.Indexes
                                , _daMgr.BuildIndexColumnAscending(Constants.TabName)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumnStructure>(Constants.SysCat
                                , Constants.Indexes
                                , _daMgr.BuildIndexColumnAscending(Constants.IndName)));

                        joinSelect.OrderByColumns.Add(4, new DbQualifiedObject<DbIndexColumnStructure>(Constants.SysCat
                                , Constants.IndexColUse
                                , _daMgr.BuildIndexColumnAscending(Constants.ColSeq)));
                        // build the dbCommand
                        DbCommand dbCmd = _daMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                default:
                    throw new ExceptionEvent(enumExceptionEventCodes.FunctionNotImplementedForDbType
                                    , _daMgr.DatabaseType.ToString());
            }
        }

        DbCommand GetCatalogForeignKeysCmd()
        {
            DbParameter paramSchemaName = _daMgr.CreateParameter(Constants.SchemaName
                    , DbType.String, null, 0, ParameterDirection.Input, null);

            DbParameter paramTableName = _daMgr.CreateParameter(Constants.TableName
                    , DbType.String, null, 0, ParameterDirection.Input, null);

            switch (_daMgr.DatabaseType)
            {
                case DataAccessMgr.EnumDbType.SqlServer:
                    {
                        // base table
                        DbTableDmlMgr joinSelect = new DbTableDmlMgr(Constants.Tables
                                    , Constants.Sys
                                    , DbTableDmlMgr.SelectColumnsAs(Constants.Name, Constants.TableName));

                        joinSelect.AddJoin(Constants.Schemas, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Schemas, Constants.Schema_Id)
                                    == j.Column(Constants.Tables, Constants.Schema_Id)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.SchemaName));

                        joinSelect.AddJoin(Constants.Foreign_Keys, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Foreign_Keys, Constants.Parent_Object_Id)
                                    == j.Column(Constants.Tables, Constants.Object_Id)
                                    , DbTableDmlMgr.SelectColumnsAs(Constants.Name, Constants.ForeignKey));

                        string fkc = joinSelect.AddJoin(Constants.Foreign_Key_Columns, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Foreign_Key_Columns, Constants.Constraint_Object_Id)
                                    == j.Column(Constants.Foreign_Keys, Constants.Object_Id));

                        joinSelect.AddJoin(Constants.Columns, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Columns, Constants.Object_Id)
                                    == j.Column(Constants.Tables, Constants.Object_Id)
                                    && j.Column(Constants.Foreign_Key_Columns, Constants.Parent_Column_Id)
                                    == j.Column(Constants.Columns, Constants.Column_Id)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.ColumnName));

                        string refT = joinSelect.AddJoin(Constants.Tables, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Foreign_Keys, Constants.Referenced_Object_Id)
                                    == j.Column(Constants.Tables, Constants.Object_Id)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.RefTable));

                        joinSelect.AddJoin(Constants.Schemas, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Schemas, Constants.Schema_Id)
                                    == j.AliasedColumn(refT, Constants.Schema_Id)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.RefSchema));

                        joinSelect.AddJoin(Constants.Columns, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Columns, Constants.Object_Id)
                                    == j.Column(Constants.Foreign_Keys, Constants.Referenced_Object_Id)
                                    && j.AliasedColumn(fkc, Constants.Referenced_Column_Id)
                                    == j.Column(Constants.Columns, Constants.Column_Id)
                                    , joinSelect.ColumnsAs(Constants.Name, Constants.ColumnName));

                        joinSelect.AddJoin(Constants.Key_Column_Usage, Constants.Information_Schema, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.Key_Column_Usage, Constants.Table_Schema)
                                    == j.Column(Constants.Schemas, Constants.Name)
                                    && j.Column(Constants.Key_Column_Usage, Constants.Column_Name)
                                    == j.Column(Constants.Columns, Constants.Name)
                                    && j.Column(Constants.Key_Column_Usage, Constants.Table_Name)
                                    == j.Column(Constants.Tables, Constants.Name)
                                    , joinSelect.ColumnsAs(Constants.Ordinal_Position, Constants.Ordinal));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.Sys, Constants.Schemas
                                , Constants.Name)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.Sys, Constants.Tables
                                , Constants.Name)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.Schemas
                                , _daMgr.BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.Tables
                                , _daMgr.BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.Foreign_Keys
                                , _daMgr.BuildIndexColumnAscending(Constants.Name)));

                        joinSelect.OrderByColumns.Add(4, new DbQualifiedObject<DbIndexColumnStructure>(
                                Constants.Information_Schema
                                , Constants.Key_Column_Usage
                                , _daMgr.BuildIndexColumnAscending(Constants.Ordinal_Position)));

                        // build the dbCommand
                        DbCommand dbCmd = _daMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                case DataAccessMgr.EnumDbType.Oracle:
                    {
                        // base table
                        DbTableDmlMgr joinSelect = new DbTableDmlMgr(Constants.All_Constraints
                                    , Constants.Sys
                                    , DbTableDmlMgr.SelectColumnsAs(Constants.Owner, Constants.SchemaName)
                                    , DbTableDmlMgr.SelectColumnsAs(Constants.Table_Name, Constants.TableName)
                                    , DbTableDmlMgr.SelectColumnsAs(Constants.Constraint_Name, Constants.ForeignKey));

                        string cc = joinSelect.AddJoin(Constants.All_Cons_Columns, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.All_Cons_Columns, Constants.Constraint_Name)
                                    == j.Column(Constants.All_Constraints, Constants.Constraint_Name)
                                    && j.Column(Constants.All_Cons_Columns, Constants.Owner)
                                    == j.Column(Constants.All_Constraints, Constants.Owner)
                                    && j.Column(Constants.All_Cons_Columns, Constants.Table_Name)
                                    == j.Column(Constants.All_Constraints, Constants.Table_Name)
                                    , joinSelect.ColumnsAs(Constants.Column_Name, Constants.ColumnName)
                                    , joinSelect.ColumnsAs(Constants.Position, Constants.Ordinal));

                        joinSelect.AddJoin(Constants.All_Cons_Columns, Constants.Sys, DbTableJoinType.Inner
                                , (j) => j.Column(Constants.All_Cons_Columns, Constants.Constraint_Name)
                                    == j.Column(Constants.All_Constraints, Constants.R_Constraint_Name)
                                    && j.Column(Constants.All_Cons_Columns, Constants.Owner)
                                    == j.Column(Constants.All_Constraints, Constants.R_Owner)
                                    && j.Column(Constants.All_Cons_Columns, Constants.Position)
                                    == j.AliasedColumn(cc, Constants.Position)
                                    , joinSelect.ColumnsAs(Constants.Owner, Constants.RefSchema)
                                    , joinSelect.ColumnsAs(Constants.Table_Name, Constants.RefTable)
                                    , joinSelect.ColumnsAs(Constants.Column_Name, Constants.RefColumn));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.Sys, Constants.All_Constraints
                                , Constants.Owner)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.Sys, Constants.All_Constraints
                                , Constants.Table_Name)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.All_Constraints
                                , _daMgr.BuildIndexColumnAscending(Constants.Owner)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.All_Constraints
                                , _daMgr.BuildIndexColumnAscending(Constants.Table_Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.All_Constraints
                                , _daMgr.BuildIndexColumnAscending(Constants.Constraint_Name)));

                        joinSelect.OrderByColumns.Add(4, new DbQualifiedObject<DbIndexColumnStructure>(Constants.Sys
                                , Constants.All_Constraints
                                , cc
                                , _daMgr.BuildIndexColumnAscending(Constants.Position)));

                        // build the dbCommand
                        DbCommand dbCmd = _daMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                case DataAccessMgr.EnumDbType.Db2:
                    {
                        // base table
                        DbTableDmlMgr joinSelect = new DbTableDmlMgr(Constants.SQLForeignKeys
                                , Constants.SysIbm
                                , DbTableDmlMgr.SelectColumnsAs(Constants.FKTable_Schem, Constants.SchemaName)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.FKTable_Name, Constants.TableName)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.FK_Name, Constants.ForeignKey)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.FKColumn_Name, Constants.ColumnName)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.PKTable_Schem, Constants.RefSchema)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.PKTable_Name, Constants.RefTable)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.PKColumn_Name, Constants.RefColumn)
                                , DbTableDmlMgr.SelectColumnsAs(Constants.Key_Seq, Constants.Ordinal));

                        joinSelect.SetWhereCondition((j) =>
                                (paramSchemaName == null || j.Column(Constants.SysIbm, Constants.SQLForeignKeys
                                , Constants.FKTable_Schem)
                                    == paramSchemaName)
                                && (paramTableName == null || j.Column(Constants.SysIbm, Constants.SQLForeignKeys
                                , Constants.FKTable_Name)
                                    == paramTableName));

                        joinSelect.OrderByColumns.Add(1, new DbQualifiedObject<DbIndexColumnStructure>(Constants.SysIbm
                                , Constants.SQLForeignKeys
                                , _daMgr.BuildIndexColumnAscending(Constants.FKTable_Schem)));

                        joinSelect.OrderByColumns.Add(2, new DbQualifiedObject<DbIndexColumnStructure>(Constants.SysIbm
                                , Constants.SQLForeignKeys
                                , _daMgr.BuildIndexColumnAscending(Constants.FKTable_Name)));

                        joinSelect.OrderByColumns.Add(3, new DbQualifiedObject<DbIndexColumnStructure>(Constants.SysIbm
                                , Constants.SQLForeignKeys
                                , _daMgr.BuildIndexColumnAscending(Constants.FK_Name)));

                        joinSelect.OrderByColumns.Add(4, new DbQualifiedObject<DbIndexColumnStructure>(Constants.SysIbm
                                , Constants.SQLForeignKeys
                                , _daMgr.BuildIndexColumnAscending(Constants.Key_Seq)));

                        // build the dbCommand
                        DbCommand dbCmd = _daMgr.BuildSelectDbCommand(joinSelect, null);
                        // set the parameters
                        dbCmd.Parameters[paramSchemaName.ParameterName].Value = DBNull.Value;
                        dbCmd.Parameters[paramTableName.ParameterName].Value = DBNull.Value;
                        return dbCmd;
                    }
                default:
                    throw new ExceptionEvent(enumExceptionEventCodes.FunctionNotImplementedForDbType
                                    , _daMgr.DatabaseType.ToString());
            }
        }

        internal DbColumnStructure GetDbColumn(string schemaName, string tableName, string columnName)
        {
            if (string.IsNullOrEmpty(schemaName))
                throw new ExceptionEvent(enumExceptionEventCodes.NullOrEmptyParameter
                            , Constants.SchemaName);

            if (string.IsNullOrEmpty(tableName))
                throw new ExceptionEvent(enumExceptionEventCodes.NullOrEmptyParameter
                            , Constants.TableName);

            if (string.IsNullOrEmpty(columnName))
                throw new ExceptionEvent(enumExceptionEventCodes.NullOrEmptyParameter
                            , Constants.ColumnName);

            // make sure the Table Cache is loaded
            GetDbTable(schemaName, tableName);
            string fullyQualifiedColumnName = schemaName.ToUpper() + "." + tableName.ToUpper() 
                    + "." + columnName.ToUpper();

            // Now lookup the column in the cache
            if (!_columnCache.Exists(fullyQualifiedColumnName))
                // if the table cache was loaded, then the column was not found
                throw new ExceptionEvent(enumExceptionEventCodes.InvalidParameterValue
                    , string.Format("{0}: {1} was not found in Database"
                                    , Constants.ColumnName, fullyQualifiedColumnName));
            // otherwise return it.
            return _columnCache.Get(fullyQualifiedColumnName);
        }


        internal DbTableStructure GetDbTable(string schemaName, string tableName)
        {
            if (string.IsNullOrEmpty(schemaName))
                throw new ExceptionEvent(enumExceptionEventCodes.NullOrEmptyParameter
                            , Constants.SchemaName);

            if (string.IsNullOrEmpty(tableName))
                throw new ExceptionEvent(enumExceptionEventCodes.NullOrEmptyParameter
                            , Constants.TableName);

            string fullyQualifiedTableName = schemaName + "." + tableName;
            return GetDbTable(fullyQualifiedTableName);
        }

        internal DbTableStructure GetDbTable(string fullyQualifiedTableName)
        {
            if (string.IsNullOrEmpty(fullyQualifiedTableName))
                throw new ExceptionEvent(enumExceptionEventCodes.NullOrEmptyParameter
                            , "fullyQualifiedTableName");

            if (!_tableCache.Exists(fullyQualifiedTableName))
                LoadCache(fullyQualifiedTableName);
            DbTableStructure cacheRef = _tableCache.Get(fullyQualifiedTableName);
            return new DbTableStructure(cacheRef);
        }


        
        /// <summary>
        /// Loads cache For a table by fully qualified table name
        /// (Schema and table Name)
        /// </summary>
        /// <param name="fullyQualifiedTableName"></param>
        void LoadCache(string fullyQualifiedTableName)
        {
            DataSet tableCache = GetCatalogData(fullyQualifiedTableName.ToUpper());
            // see if table was found
            if (tableCache.Tables[Constants.Columns].Rows.Count == 0)
                throw new ExceptionEvent(enumExceptionEventCodes.InvalidParameterValue
                            , string.Format("{0}: {1} was not found in Database"
                                    , DataAccess.Constants.TableName, fullyQualifiedTableName));

            // otherwise populate the cache
            PopulateCache(tableCache.Tables[Constants.PrimaryKeys]
                        , tableCache.Tables[Constants.Columns]
                        , tableCache.Tables[Constants.Indexes]
                        , tableCache.Tables[Constants.ForeignKeys]);
        }

        /// <summary>
        /// Get the Catalog Data from the Database by fully qualified table name
        /// (Schema and Table Name)
        /// </summary>
        /// <param name="fullyQualifiedTableName"></param>
        /// <returns>A dataset of catalog data</returns>
        DataSet GetCatalogData(string fullyQualifiedTableName)
        {
            string[] nameParts = fullyQualifiedTableName.Split(new char[] { '.' });
            string schemaName = nameParts[0];
            string tableName = nameParts[1];
            return GetCatalogData(schemaName, tableName);
        }


        DataSet GetCatalogData(string schemaName, string tableName)
        {
            string schemaNameUpper = !string.IsNullOrEmpty(schemaName) ? schemaName.ToUpper() : null;
            string tableNameUpper = !string.IsNullOrEmpty(tableName) ? tableName.ToUpper() : null;
            List<string> tableNames = new List<string>();
            DbCommandMgr dbCmdMgr = new DbCommandMgr(_daMgr);
            DbCommand cmdPrimaryKey = _daMgr.CloneDbCommand(_daMgr.InternalDbCmdCache.Get(Constants.USP_CatalogGetPrimaryKeys));
            if (!string.IsNullOrEmpty(schemaNameUpper))
                cmdPrimaryKey.Parameters[dbCmdMgr.BuildParamName(Constants.SchemaName)].Value = schemaNameUpper;
            else cmdPrimaryKey.Parameters[dbCmdMgr.BuildParamName(Constants.SchemaName)].Value = DBNull.Value;

            if (!string.IsNullOrEmpty(tableNameUpper))
                cmdPrimaryKey.Parameters[dbCmdMgr.BuildParamName(Constants.TableName)].Value = tableNameUpper;
            else cmdPrimaryKey.Parameters[dbCmdMgr.BuildParamName(Constants.TableName)].Value = DBNull.Value;

            dbCmdMgr.AddDbCommand(cmdPrimaryKey);
            tableNames.Add(Constants.PrimaryKeys);

            DbCommand cmdIndex = _daMgr.CloneDbCommand(_daMgr.InternalDbCmdCache.Get(Constants.USP_CatalogGetIndexes));
            if (!string.IsNullOrEmpty(schemaNameUpper))
                cmdIndex.Parameters[dbCmdMgr.BuildParamName(Constants.SchemaName)].Value = schemaNameUpper;
            else cmdIndex.Parameters[dbCmdMgr.BuildParamName(Constants.SchemaName)].Value = DBNull.Value;

            if (!string.IsNullOrEmpty(tableNameUpper))
                cmdIndex.Parameters[dbCmdMgr.BuildParamName(Constants.TableName)].Value = tableNameUpper;
            else cmdIndex.Parameters[dbCmdMgr.BuildParamName(Constants.TableName)].Value = DBNull.Value;

            dbCmdMgr.AddDbCommand(cmdIndex);
            tableNames.Add(Constants.Indexes);

            DbCommand cmdForeignKeys = _daMgr.CloneDbCommand(_daMgr.InternalDbCmdCache.Get(Constants.USP_CatalogGetForeignKeys));
            if (!string.IsNullOrEmpty(schemaNameUpper))
                cmdForeignKeys.Parameters[dbCmdMgr.BuildParamName(Constants.SchemaName)].Value = schemaNameUpper;
            else cmdForeignKeys.Parameters[dbCmdMgr.BuildParamName(Constants.SchemaName)].Value = DBNull.Value;

            if (!string.IsNullOrEmpty(tableNameUpper))
                cmdForeignKeys.Parameters[dbCmdMgr.BuildParamName(Constants.TableName)].Value = tableNameUpper;
            else cmdForeignKeys.Parameters[dbCmdMgr.BuildParamName(Constants.TableName)].Value = DBNull.Value;

            dbCmdMgr.AddDbCommand(cmdForeignKeys);
            tableNames.Add(Constants.ForeignKeys);

            DbCommand cmdColumns = _daMgr.CloneDbCommand(_daMgr.InternalDbCmdCache.Get(Constants.USP_CatalogGetColumns));
            if (!string.IsNullOrEmpty(schemaNameUpper))
                cmdColumns.Parameters[dbCmdMgr.BuildParamName(Constants.SchemaName)].Value = schemaNameUpper;
            else cmdColumns.Parameters[dbCmdMgr.BuildParamName(Constants.SchemaName)].Value = DBNull.Value;

            if (!string.IsNullOrEmpty(tableNameUpper))
                cmdColumns.Parameters[dbCmdMgr.BuildParamName(Constants.TableName)].Value = tableNameUpper;
            else cmdColumns.Parameters[dbCmdMgr.BuildParamName(Constants.TableName)].Value = DBNull.Value;

            dbCmdMgr.AddDbCommand(cmdColumns);
            tableNames.Add(Constants.Columns);

            return dbCmdMgr.ExecuteDataSet(tableNames);
        }

        void PopulateCache(DataTable primaryKey, DataTable columns, DataTable indexes, DataTable foreignKeys)
        {
            DbTableStructure table = PopulateColumnCache(columns);
            table.PrimaryKeyColumns = GetPrimaryKeyColumns(table.SchemaName, table.TableName, primaryKey);
            table.PrimaryKey = GetPrimaryKey(table.SchemaName, table.TableName, primaryKey);
            table.Indexes = GetIndexes(table.SchemaName, table.TableName, table.Columns, indexes);
            table.ForeignKeys = GetForeignKeys(table.SchemaName, table.TableName, foreignKeys);
            _tableCache.Add(table.FullyQualifiedName, table);
        }

        Dictionary<string, DbIndexStructure> GetIndexes(string tableSchema
                , string tableName
                , Dictionary<string, Int16> tableColumns
                , DataTable indexes)
        {
            DataRow[] tableIndexes = indexes.Select(string.Format("{0} = '{1}' and {2} = '{3}'"
                                                        , Constants.SchemaName
                                                        , tableSchema
                                                        , Constants.TableName
                                                        , tableName));
            Dictionary<string, DbIndexStructure> tableIndexCollection 
                    = new Dictionary<string, DbIndexStructure>(StringComparer.CurrentCultureIgnoreCase);

            DbIndexStructure index = new DbIndexStructure();
            index.Columns = new SortedDictionary<short, DbIndexColumnStructure>();
            for (byte i = 0; i < tableIndexes.Length; i++)
            {
                if (string.IsNullOrEmpty(index.IndexName)
                    || tableIndexes[i][Constants.IndexName].ToString().ToUpper() != index.IndexName.ToUpper())
                {
                    // we are on a new index
                    // save the previous one if there was one
                    if (!string.IsNullOrEmpty(index.IndexName))
                    {
                        tableIndexCollection.Add(index.IndexName, index);
                        index = new DbIndexStructure();
                        index.Columns = new SortedDictionary<short, DbIndexColumnStructure>();
                    }

                    index.IndexName = tableIndexes[i][Constants.IndexName].ToString();
                    index.SchemaName = tableSchema;
                    index.TableName = tableName;
                    index.IsPrimaryKey = Convert.ToBoolean(tableIndexes[i][Constants.IsPrimaryKey]);
                    index.IsUnique = Convert.ToBoolean(tableIndexes[i][Constants.IsUnique]);
                }
                DbIndexColumnStructure indexColumn = new DbIndexColumnStructure();
                indexColumn.ColumnFunction = tableIndexes[i][Constants.ColumnFunction].ToString();
                if (string.IsNullOrEmpty(indexColumn.ColumnFunction))
                    indexColumn.ColumnName = tableIndexes[i][Constants.ColumnName].ToString();
                else // we must parse the column name from the function (Oracle - functional based index)
                {
                    foreach (string column in tableColumns.Keys)
                        if (indexColumn.ColumnFunction.Contains(column))
                        {
                            indexColumn.ColumnName = column;
                            break;
                        }
                }
                indexColumn.IsDescending = Convert.ToBoolean(tableIndexes[i][Constants.IsDescend]);
                index.Columns.Add(Convert.ToInt16(tableIndexes[i][Constants.Ordinal]), indexColumn);
            }
            if (!string.IsNullOrEmpty(index.IndexName))
                tableIndexCollection.Add(index.IndexName, index);
            return tableIndexCollection;
        }


        Dictionary<string, DbForeignKeyStructure> GetForeignKeys(string tableSchema, string tableName, DataTable foreignKeys)
        {
            DataRow[] tableForeignKeys = foreignKeys.Select(string.Format("{0} = '{1}' and {2} = '{3}'"
                                                        , Constants.SchemaName
                                                        , tableSchema
                                                        , Constants.TableName
                                                        , tableName));

            Dictionary<string, DbForeignKeyStructure> tableFKeyCollection
                    = new Dictionary<string, DbForeignKeyStructure>(StringComparer.CurrentCultureIgnoreCase);

            DbForeignKeyStructure foreignKey = new DbForeignKeyStructure();
            foreignKey.KeyColumns = new Dictionary<string, string>(StringComparer.CurrentCultureIgnoreCase);
            foreignKey.KeyOrder = new SortedDictionary<Int16, string>();
            for (byte i = 0; i < tableForeignKeys.Length; i++)
            {
                if (string.IsNullOrEmpty(foreignKey.ForeignKeyName)
                    || tableForeignKeys[i][Constants.ForeignKey].ToString().ToUpper() != foreignKey.ForeignKeyName.ToUpper())
                {
                    // we are on a new index
                    // save the previous one if there was one
                    if (!string.IsNullOrEmpty(foreignKey.ForeignKeyName))
                    {
                        tableFKeyCollection.Add(foreignKey.ForeignKeyName, foreignKey);
                        foreignKey = new DbForeignKeyStructure();
                        foreignKey.KeyColumns = new Dictionary<string, string>(StringComparer.CurrentCultureIgnoreCase);
                        foreignKey.KeyOrder = new SortedDictionary<Int16, string>();
                    }
                    foreignKey.ForeignKeyName = tableForeignKeys[i][Constants.ForeignKey].ToString();   
                    foreignKey.SchemaName = tableForeignKeys[i][DataAccess.Constants.RefSchema].ToString();
                    foreignKey.TableName = tableForeignKeys[i][DataAccess.Constants.RefTable].ToString();
                }

                foreignKey.KeyColumns.Add(tableForeignKeys[i][Constants.ColumnName].ToString(), tableForeignKeys[i][Constants.RefTable].ToString());
                foreignKey.KeyOrder.Add(Convert.ToInt16(tableForeignKeys[i][Constants.Ordinal]), tableForeignKeys[i][Constants.ColumnName].ToString());
            }
            if (!string.IsNullOrEmpty(foreignKey.ForeignKeyName))
                tableFKeyCollection.Add(foreignKey.ForeignKeyName, foreignKey);
            return tableFKeyCollection;
        }

        Dictionary<string, byte> GetPrimaryKeyColumns(string tableSchema, string tableName, DataTable primaryKey)
        {
            DataRow[] primaryKeyCols = primaryKey.Select(string.Format("{0} = '{1}' and {2} = '{3}'"
                                                        , Constants.SchemaName
                                                        , tableSchema
                                                        , Constants.TableName
                                                        , tableName));
            Dictionary<string, byte> primaryKeyColumnNames 
                    = new Dictionary<string, byte>(StringComparer.CurrentCultureIgnoreCase);
            for (byte i = 0; i < primaryKeyCols.Length; i++)
                primaryKeyColumnNames.Add(primaryKeyCols[i][Constants.ColumnName].ToString()
                        , i);
            return primaryKeyColumnNames;
        }

        SortedDictionary<byte, string> GetPrimaryKey(string tableSchema, string tableName, DataTable primaryKey)
        {
            DataRow[] primaryKeyCols = primaryKey.Select(string.Format("{0} = '{1}' and {2} = '{3}'"
                                                        , Constants.SchemaName
                                                        , tableSchema
                                                        , Constants.TableName
                                                        , tableName));
            SortedDictionary<byte, string> primaryKeyColumnNames = new SortedDictionary<byte, string>();
            for (byte i = 0; i < primaryKeyCols.Length; i++)
                primaryKeyColumnNames.Add(i, primaryKeyCols[i][Constants.ColumnName].ToString());
            return primaryKeyColumnNames;
        }

        DbTableStructure PopulateColumnCache(DataTable columns)
        {
            DbCommandMgr dbCmdMgr = new DbCommandMgr(_daMgr);
            DbTableStructure table = new DbTableStructure();
            table.SchemaName = columns.Rows[0][EnumTableAttributes.SchemaName.ToString()].ToString();
            table.TableName = columns.Rows[0][EnumTableAttributes.TableName.ToString()].ToString();
            table.Columns = new Dictionary<string, Int16>(StringComparer.CurrentCultureIgnoreCase);
            table.Row = new SortedDictionary<Int16, string>();
            foreach (DataRow columnRow in columns.Rows)
            {
                try
                {
                    DbColumnStructure column = new DbColumnStructure();
                    column.SchemaName = columnRow[EnumColumnAttributes.SchemaName.ToString()].ToString();
                    column.TableName = columnRow[EnumColumnAttributes.TableName.ToString()].ToString();
                    column.ColumnName = columnRow[EnumColumnAttributes.ColumnName.ToString()].ToString();
                    column.Ordinal = Convert.ToInt16(columnRow[EnumColumnAttributes.OrdinalPosition.ToString()]);

                    table.Columns.Add(column.ColumnName, column.Ordinal);
                    column.DataTypeNativeDb = columnRow[EnumColumnAttributes.DataType.ToString()].ToString();

                    if (columnRow[EnumColumnAttributes.NumericPrecision.ToString()] != DBNull.Value)
                        column.Precision = Convert.ToInt16(columnRow[EnumColumnAttributes.NumericPrecision.ToString()]);
                    if (columnRow[EnumColumnAttributes.NumericPrecisionRadix.ToString()] != DBNull.Value)
                        column.Radix = Convert.ToInt16(columnRow[EnumColumnAttributes.NumericPrecisionRadix.ToString()]);
                    if (columnRow[EnumColumnAttributes.NumericScale.ToString()] != DBNull.Value)
                        column.Scale = Convert.ToInt16(columnRow[EnumColumnAttributes.NumericScale.ToString()]);

                    if (_daMgr.DatabaseType == DataAccessMgr.EnumDbType.Oracle
                        && column.DataTypeNativeDb.ToLower() == "number")
                    {
                        column.DataTypeDotNet = _daMgr.GetDotNetDataTypeFromNativeDataType(
                                                                            column.DataTypeNativeDb
                                                                            , column.Precision
                                                                            , column.Scale);
                        column.DataTypeGenericDb = _daMgr.GetGenericDbTypeFromNativeDataType(
                                                                            column.DataTypeNativeDb
                                                                            , column.Precision
                                                                            , column.Scale);
                        column.DataTypeDataColumn = "System.Decimal";
                    }
                    else
                    {
                        column.DataTypeDotNet = column.DataTypeDataColumn = _daMgr.GetDotNetDataTypeFromNativeDataType(
                                                                                column.DataTypeNativeDb);
                        column.DataTypeGenericDb = _daMgr.GetGenericDbTypeFromNativeDataType(
                                                                            column.DataTypeNativeDb);
                    }

                    column.IsNullable = Convert.ToBoolean(columnRow[EnumColumnAttributes.IsNullable.ToString()]);
                    column.IsAutoGenerated = Convert.ToBoolean(columnRow[EnumColumnAttributes.IsIdentity.ToString()]);
                    column.HasDefault = columnRow[EnumColumnAttributes.ColumnDefault.ToString()] == DBNull.Value ? false : true;
                    if (columnRow[EnumColumnAttributes.CharacterMaximumLength.ToString()] != DBNull.Value)
                        column.MaxLength = Convert.ToInt32(columnRow[EnumColumnAttributes.CharacterMaximumLength.ToString()]);

                    table.Row.Add(column.Ordinal, column.ColumnName);
                    // add to column cache
                    _columnCache.Set(column.FullyQualifiedName, column);
                }
                catch (Exception exc)
                {
                    string msg = string.Format("Schema: {0}; Table: {1}; Column:{2}"
                            , table.SchemaName
                            , table.TableName
                            , columnRow[EnumColumnAttributes.ColumnName.ToString()]);
                throw new ExceptionEvent(enumExceptionEventCodes.UnknownException
                                    , msg, exc);
                }
            }
            return table;
        }
    }
}
