using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Data;
using System.Data.Common;
using System.Reflection;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Json;

using B1.Core;
using B1.ILoggingManagement;

namespace B1.DataAccess
{
    /// <summary>
    /// Paging Manager - This class encapsulates the functionality to retreive result set data
    /// from the database in tunable (pageSize) buffers (pages) with consistent, efficient
    /// access times for both forward and backward directions as well as first and last pages.
    /// NOTE: This class does NOT perform a count of the result set because that would defeat
    /// the purpose of scalability.  Therefore it is not possible to know how many
    /// pages there are/will be in a result set.  In addition, the class does not provide
    /// an interface for returning the 'nth page as this would not be efficient.
    /// You can however choose to calculate a rowcount and perform some heuristic to simulate
    /// the key of the n'th page.
    /// 
    /// The functionality requires that queries use indexes, specifically unique indexes.
    /// The indexes are necessary for efficient data access therefore the class will 
    /// verify their existence and throw an exception if they are not defined properly.
    /// 
    /// The queries written by the class (or passed in by the caller), must be written so
    /// that they have an execution plan that utilizes the index.  Once the page size has
    /// been fetched the query is stopped and the resources released.
    /// 
    /// In addition, the result set of the queries must include the columns of the index
    /// used in the query, so that the class will have the pointers (values of the keys)
    /// to use in the subsequent query (>= for next;  etc).  The first and last page
    /// queries do not require key values so they can be different commands.  If there were
    /// 'magic values' (such as 0) then the same query can be used for next and first as well 
    /// as previous and last.
    /// 
    /// The page size can be defined once at construction and remain consistent for all 
    /// subsequent queries; or it can be overwritten on each subsequent call for getting a page.
    /// To do this, the class adds a parameter to the dbCommands. (Constants.PageSize)
    /// </summary>
    public class PagingMgr
    {
        /// <summary>
        /// Default value for a page size if none is provided
        /// Page size corresponds to the number of rows returned in a query.
        /// </summary>
        public const Int16 CONST_DefaultPageSize = 500;

        DataAccessMgr _daMgr = null;
        Dictionary<string, string> _pageKeys = null;
        Dictionary<string, object> _pageFirstItem = null;
        Dictionary<string, object> _pageLastItem = null;
        Int16 _pageSize = CONST_DefaultPageSize;
        string _pageSizeParam = null;
        int _paramOffset = 0;
        public enum PagingDbCmdEnum { First, Last, Next, Previous };

        DbCommand _dbCmdFirstPage = null;
        DbCommand _dbCmdLastPage = null;
        DbCommand _dbCmdNextPage = null;
        DbCommand _dbCmdPreviousPage = null;

        /// <summary>
        /// Baseline constructor used internally for setting member variables
        /// </summary>
        /// <param name="dataAccessManager">DataAccessMgr class pointer</param>
        /// <param name="pageSizeParam"> Parameter name to be used to set page size for page requests</param>
        /// <param name="pageSize">The default page size or null; if pageSize is less than or equal to 0
        /// , then the class default will used (500)</param>
        /// <param name="pagingState">Optional paging state string generated by GetPagingState()</param>
        private PagingMgr(DataAccessMgr dataAccessManager
                , string pageSizeParam
                , Int16? pageSize
                , string pagingState = null)
        {
            _daMgr = dataAccessManager;
            // if page size param is not provided, used default
            _pageSizeParam = !string.IsNullOrEmpty(pageSizeParam) ? pageSizeParam : Constants.PageSize;
            if (pageSize.HasValue && pageSize.Value > 0)
                _pageSize = pageSize.Value;
            // Oracle parameters do not start with a special character, so the name starts at positions 0
            _paramOffset = _daMgr.DatabaseType == DataAccessMgr.EnumDbType.Oracle ? 0 : 1;
            // initialize the keys for the first/last item in a page
            _pageKeys = new Dictionary<string, string>(StringComparer.CurrentCultureIgnoreCase);
            _pageFirstItem = new Dictionary<string, object>(StringComparer.CurrentCultureIgnoreCase);
            _pageLastItem = new Dictionary<string, object>(StringComparer.CurrentCultureIgnoreCase);

            RestorePagingState(pagingState);
        }

        /// <summary>
        /// Constructor that allows programmer to provide DbCommands for paging forward/backward
        /// </summary>
        /// <param name="dataAccessManager">DataAccessMgr class pointer</param>
        /// <param name="dbCmdFirstPage">DbCommandfor obtaining first page</param>
        /// <param name="dbCmdLastPage">DbCommand for obtaining last page</param>
        /// <param name="dbCmdNextPage">DbCommand for obtaining next page </param>
        /// <param name="dbCmdPreviousPage">DbCommand for obtaining first page</param>
        /// <param name="pageSizeParam"> Parameter name to be used to set page size for page requests</param>
        /// <param name="pageSize">The default page size or null; if pageSize is less than or equal to 0
        /// , then the class default will used (500)</param>
        /// <param name="pagingState">Optional paging state string generated by GetPagingState()</param>
        public PagingMgr(DataAccessMgr dataAccessManager
                , DbCommand dbCmdFirstPage
                , DbCommand dbCmdLastPage
                , DbCommand dbCmdNextPage
                , DbCommand dbCmdPreviousPage
                , string pageSizeParam
                , Int16? pageSize
                , string pagingState = null) : this (dataAccessManager, pageSizeParam, pageSize, pagingState)
        {
            Initialize(dbCmdFirstPage
                    , dbCmdLastPage
                    , dbCmdNextPage
                    , dbCmdPreviousPage);
        }

        /// <summary>
        /// Constructor that accepts a fully qualified table name and builds the paging commands
        /// for forward/backward paging using the PrimaryKey of the table.
        /// NOTE:
        /// If the table does not have a primary key, this contructor will raise an exception
        /// </summary>
        /// <param name="dataAccessManager">DataAccessMgr class pointer</param>
        /// <param name="dbTable">catalog metadata about the table; including which columns to select</param>
        /// <param name="indexColumns">A string array of column names that need to be part of an index; 
        /// NULL if using Primary Key of table</param>
        /// <param name="pageSizeParam"> Parameter name to be used to set page size for page requests</param>
        /// <param name="pageSize">The default page size or null; if pageSize is less than or equal to 0
        /// , then the class default will used (500)</param>
        /// <param name="pagingState">Optional paging state string generated by GetPagingState()</param>
        public PagingMgr(DataAccessMgr dataAccessManager
                , DbTableStructure dbTable
                , List<string> indexColumns
                , string pageSizeParam
                , Int16? pageSize
                , string pagingState = null)
            : this(dataAccessManager, pageSizeParam, pageSize, pagingState)
        {
            indexColumns = VerifyIndexColumns(dbTable, indexColumns);

            DbCommand dbCmdFirstPage = GetPageDbCmd(PagingDbCmdEnum.First
                    , dbTable
                    , indexColumns);
            DbCommand dbCmdLastPage = GetPageDbCmd(PagingDbCmdEnum.Last
                    , dbTable
                    , indexColumns);
            DbCommand dbCmdNextPage = GetPageDbCmd(PagingDbCmdEnum.Next
                    , dbTable
                    , indexColumns);
            DbCommand dbCmdPreviousPage = GetPageDbCmd(PagingDbCmdEnum.Previous
                    , dbTable
                    , indexColumns);

            Initialize(dbCmdFirstPage
                    , dbCmdLastPage
                    , dbCmdNextPage
                    , dbCmdPreviousPage);
        }

        /// <summary>
        /// Constructor that accepts a fully qualified table name and builds the paging commands
        /// for forward/backward paging using the PrimaryKey of the table.
        /// NOTE:
        /// If the table does not have a primary key, this contructor will raise an exception
        /// </summary>
        /// <param name="dataAccessManager">DataAccessMgr class pointer</param>
        /// <param name="fullyQualifiedTableName">Fully qualified table name to perform paging on</param>
        /// <param name="pageSizeParam"> Parameter name to be used to set page size for page requests</param>
        /// <param name="pageSize">The default page size or null; if pageSize is less than or equal to 0
        /// , then the class default will used (500)</param>
        /// <param name="pagingState">Optional paging state string generated by GetPagingState()</param>
        public PagingMgr(DataAccessMgr dataAccessManager
                , string fullyQualifiedTableName
                , string pageSizeParam
                , Int16? pageSize
                , string pagingState = null)
            : this(dataAccessManager
                , dataAccessManager.DbCatalogGetTable(fullyQualifiedTableName)
                , null
                , pageSizeParam
                , pageSize
                , pagingState)
        {           
        }


        /// <summary>
        /// Constructor that accepts catalog metadata structure for the table and builds the paging commands
        /// for forward/backward paging using the PrimaryKey of the table.
        /// NOTE:
        /// If the table does not have a primary key, this contructor will raise an exception
        /// </summary>
        /// <param name="dataAccessManager">DataAccessMgr class pointer</param>
        /// <param name="dbTable">catalog metadata about the table; including which columns to select</param>
        /// <param name="pageSizeParam"> Parameter name to be used to set page size for page requests</param>
        /// <param name="pageSize">The default page size or null; if pageSize is less than or equal to 0
        /// , then the class default will used (500)</param>
        /// <param name="pagingState">Optional paging state string generated by GetPagingState()</param>
        public PagingMgr(DataAccessMgr dataAccessManager
                , DbTableStructure dbTable
                , string pageSizeParam
                , Int16? pageSize
                , string pagingState = null)
            : this(dataAccessManager
                , dbTable
                , null
                , pageSizeParam
                , pageSize
                , pagingState)
        {
        }
        /// <summary>
        /// Constructor that accepts a fully qualified table name and builds the paging commands
        /// for forward/backward paging using the given column list.
        /// NOTE:
        /// If the table does not have an index (including primary key), that covers the columns 
        /// given to this contructor, it will raise an exception.
        /// </summary>
        /// <param name="dataAccessManager">DataAccessMgr class pointer</param>
        /// <param name="fullyQualifiedTableName">Fully qualified table name to perform paging on</param>
        /// <param name="indexColumns">A string array of column names that need to be part of an index</param>
        /// <param name="pageSizeParam"> Parameter name to be used to set page size for page requests</param>
        /// <param name="pageSize">The default page size or null; if pageSize is less than or equal to 0
        /// , then the class default will used (500)</param>
        /// <param name="pagingState">Optional paging state string generated by GetPagingState()</param>
        public PagingMgr(DataAccessMgr dataAccessManager
                , string fullyQualifiedTableName
                , List<string> indexColumns
                , string pageSizeParam
                , Int16? pageSize
                , string pagingState = null)
            : this(dataAccessManager
                , dataAccessManager.DbCatalogGetTable(fullyQualifiedTableName)
                , indexColumns
                , pageSizeParam
                , pageSize
                , pagingState)
        {
        }

        /// <summary>
        /// Uses a DbTableDmlMgr to build a PagingMgr.
        /// DbTableDmlMgr can represent a select with one or more tables(join) and contain an existing
        /// where condition. The PagingMgr will append to the existing where condition to perform the 4 basic
        /// paging commands: first, last, prev, next.
        /// Order by columns will be ignored.
        /// </summary>
        /// <param name="dataAccessManager">DataAccessMgr class pointer</param>
        /// <param name="dmlSelect">DbTableDmlMgr with table(s) and where condition.</param>
        /// <param name="pageSizeParam"> Parameter name to be used to set page size for page requests</param>
        /// <param name="pageSize">The default page size or null; if pageSize is less than or equal to 0</param>
        /// <param name="pagingState">Optional paging state string generated by GetPagingState()</param>
        public PagingMgr(DataAccessMgr dataAccessManager
                , DbTableDmlMgr dmlSelect
                , string pageSizeParam
                , Int16? pageSize
                , string pagingState = null) : this (dataAccessManager, pageSizeParam, pageSize, pagingState)
        {
            List<string> indexColumns = new List<string>();
            foreach (DbQualifiedObject<DbIndexColumnStructure> index in dmlSelect.OrderByColumns.Values)
                indexColumns.Add(index.DbObject.ColumnName);

            indexColumns = VerifyIndexColumns(dataAccessManager.DbCatalogGetTable(
                    dmlSelect.MainTable.SchemaName, dmlSelect.MainTable.TableName), indexColumns);

            DbCommand dbCmdFirstPage = GetPageDbCmd(PagingDbCmdEnum.First
                    , dmlSelect
                    , indexColumns);
            DbCommand dbCmdLastPage = GetPageDbCmd(PagingDbCmdEnum.Last
                    , dmlSelect
                    , indexColumns);
            DbCommand dbCmdNextPage = GetPageDbCmd(PagingDbCmdEnum.Next
                    , dmlSelect
                    , indexColumns);
            DbCommand dbCmdPreviousPage = GetPageDbCmd(PagingDbCmdEnum.Previous
                    , dmlSelect
                    , indexColumns);

            Initialize(dbCmdFirstPage
                    , dbCmdLastPage
                    , dbCmdNextPage
                    , dbCmdPreviousPage);
        }

        public PagingMgr(DataAccessMgr dataAccessManager
            , IQueryable queryable
            , string pageSizeParam
            , Int16? pageSize
            , string pagingState = null) : this (dataAccessManager, pageSizeParam, pageSize, pagingState)
        {
            LinqQueryParser parser = new LinqQueryParser(queryable, dataAccessManager, null);

            // Get the base table (main "from" table)
            var baseTableInfo = parser.GetBaseTableInfo(); // Returns "B1", "T0", "TestSequence"
            string schemaName = baseTableInfo[0];
            string aliasName = baseTableInfo[1];
            string tableName = baseTableInfo[2];

            // Check the orderby columns if they are in the base table index
            // If no orderby defined then returns the primary key of the table
            var orderByColumns = parser.GetOrderByColumnList();
            var indexColumns = VerifyIndexColumns(
                dataAccessManager.DbCatalogGetTable(string.Format("{0}.{1}", schemaName, tableName)),
                orderByColumns != null ? orderByColumns.Select(col => col.Item1).ToList() : null);

            string select = parser.GetOuterSelect();
            string from = parser.GetOuterFrom();
            if (from == null)
                from = parser.GetDefaultFrom();

            string whereClause = parser.GetWhereClause();
            string groupBy = parser.GetOuterGroupBy();

            DbTableDmlMgr dbTableDmlMgr = new DbTableDmlMgr(schemaName, tableName, aliasName, dataAccessManager);

            Func<PagingDbCmdEnum, DbCommand> func = pagingDbCmd =>
            {
                IEnumerable<DbPredicateParameter> parameters = parser.Parameters ?? new List<DbPredicateParameter>();

                // Construct the select command: SELECT ... FROM ... INNER JOIN ...
                StringBuilder selectCmd = new StringBuilder(
                    string.Format("{0}{1} FROM {2}", select, Environment.NewLine, from));

                // Create a paging WHERE clause
                var pagingWhereExpression = GetPagingWhereClause(pagingDbCmd, tableName, indexColumns);
                string pagingWhereClause = null;
                if (pagingWhereExpression != null)
                {
                    DbPredicate dbPredicate = new DbPredicate(
                        Expression.Lambda<Func<DbTableDmlMgr, bool>>(pagingWhereExpression,
                        Expression.Parameter(typeof(DbTableDmlMgr), "j")), dbTableDmlMgr);
                    pagingWhereClause = dbPredicate.ToString(dataAccessManager);
                    parameters = parameters.Concat(dbPredicate.Parameters.Select(kv => kv.Value));
                }

                // Build WHERE clause with the one in the LINQ query and the one needed for supporting paging
                if (!string.IsNullOrWhiteSpace(whereClause) && !string.IsNullOrWhiteSpace(pagingWhereClause))
                {
                    selectCmd.AppendFormat("{0}WHERE ({1}) AND ({2})", Environment.NewLine, whereClause, pagingWhereClause);
                }
                else if (!string.IsNullOrWhiteSpace(whereClause))
                {
                    selectCmd.AppendFormat("{0}WHERE {1}", Environment.NewLine, whereClause);
                } else if (!string.IsNullOrWhiteSpace(pagingWhereClause))
                {
                    selectCmd.AppendFormat("{0}WHERE {1}", Environment.NewLine, pagingWhereClause);
                }

                if (!string.IsNullOrWhiteSpace(groupBy))
                    selectCmd.AppendFormat("{0}{1}", Environment.NewLine, groupBy);

                // Create the orderby from the index used in paging
                string sort = pagingDbCmd == PagingDbCmdEnum.First || pagingDbCmd == PagingDbCmdEnum.Next ? "ASC" : "DESC";
                string orderby = indexColumns.Aggregate(new StringBuilder(),
                    (sb, column) => sb.AppendFormat(" {0} {1},", column, sort)).ToString();
                selectCmd.AppendFormat("{0}ORDER BY {1}", Environment.NewLine, orderby.Remove(orderby.Length - 1));

                // Build the where clause parameters
                DbParameterCollection dbParams = dataAccessManager.BuildWhereClauseParams(parameters);
                string cmdText = dataAccessManager.FormatSQLSelectWithMaxRows(selectCmd.ToString(), pageSizeParam);
                // Add pageSize parameter to the parameter collection
                if (dbParams == null)
                    dbParams = dataAccessManager.CreateNewParameterAndCollection(pageSizeParam
                                        , DbType.Int32
                                        , null
                                        , 0
                                        , ParameterDirection.Input
                                        , DBNull.Value);
                else dataAccessManager.AddNewParameterToCollection(dbParams
                                        , pageSizeParam
                                        , DbType.Int32
                                        , null
                                        , 0
                                        , ParameterDirection.Input
                                        , DBNull.Value);
                DbCommand dbCmd = dataAccessManager.BuildSelectDbCommand(cmdText, dbParams);
                dbCmd.Site = new ParameterSite(parser.Parameters);
                return dbCmd;
            };

            // Create the where clause flavors for the first, next, previous and last page
            DbCommand dbCmdFirstPage = func(PagingDbCmdEnum.First);
            DbCommand dbCmdLastPage = func(PagingDbCmdEnum.Last);
            DbCommand dbCmdNextPage = func(PagingDbCmdEnum.Next);
            DbCommand dbCmdPreviousPage = func(PagingDbCmdEnum.Previous);

            Initialize(dbCmdFirstPage, dbCmdLastPage, dbCmdNextPage, dbCmdPreviousPage);
        }

        List<string> VerifyIndexColumns(DbTableStructure dbTable
                , List<string> indexColumns)
        {
            // Verify that the table has a PrimaryKey or an Index that matches the index column list
            if (indexColumns == null
                || indexColumns.Count == 0)
            {
                if (dbTable.PrimaryKey == null
                    || dbTable.PrimaryKey.Count == 0)
                {
                    throw new ExceptionEvent(enumExceptionEventCodes.DbTablePrimaryKeyUndefined
                            , string.Format("Table: {0} was not defined with a PrimaryKey and no alternative key "
                            + "was provided for PagingMgr."
                                , dbTable.FullyQualifiedName));
                }
                else
                {
                    indexColumns = new List<string>();
                    foreach (byte columnIndex in dbTable.PrimaryKey.Keys)
                        indexColumns.Add(dbTable.PrimaryKey[columnIndex]);
                }
            }
            else
            {
                if (!VerifyIndex(dbTable, indexColumns))
                    // we did not find an index that matches the given columns
                    throw new ExceptionEvent(enumExceptionEventCodes.DbTableIndexNotFound
                            , string.Format("The table: {0} did not have an index defined that contained the column list: "
                                + "{1} requested for paging."
                                , dbTable.FullyQualifiedName
                                , string.Join(", ", indexColumns)));
            }
            
            return indexColumns;
        }

        bool VerifyIndex(DbTableStructure dbTable
                , List<string> indexColumns)
        {
            if (dbTable.Indexes.Count > 0)
                foreach (string indexName in dbTable.Indexes.Keys)
                {
                    DbIndexStructure index = dbTable.Indexes[indexName];
                    Int16 matchedColCount = 0;  // number of matched columns

                    foreach (byte columnIndex in index.Columns.Keys)
                    {
                        if (index.Columns[columnIndex].ColumnName.ToLower()
                            != indexColumns[columnIndex - 1].ToLower())
                            break;
                        else
                        {
                            // once we have found a unique index that is covered
                            // by the requested index column list, we are done
                            // even if the requested index has more columns
                            // they wont affect the sort order because the left most
                            // portion of the index is unique already.
                            if (++matchedColCount == indexColumns.Count)
                                return true;
                        }
                    }
                }
            return false;
        }

        DbCommand GetPageDbCmd( PagingDbCmdEnum pagingDbCmd
                , DbTableStructure dbTable
                , List<string> indexColumns )
        {
            return GetPageDbCmd(pagingDbCmd, 
                    _daMgr.DbCatalogGetTableDmlMgr( dbTable.FullyQualifiedName, dbTable.Columns.Keys.ToArray() ),
                    indexColumns);
        }

        Expression GetPagingWhereClause(PagingDbCmdEnum pagingDbCmd,
            string tableName, List<string> indexColumns)
        {
            Int16 i;
            Int16 columnIndex;
            Expression expr;
            Expression exprAnd;
            Expression exprWhere = null;
            //DbTableDmlMgr dbTableDml = new DbTableDmlMgr(dbTableDmlSelect);
            //dbTableDml.OrderByColumns.Clear();

            columnIndex = -1;
            foreach (string column in indexColumns)
            {
                columnIndex++;

                if (!_pageKeys.ContainsKey(column))
                    _pageKeys.Add(column, column);

                //if (pagingDbCmd == PagingDbCmdEnum.First
                //        || pagingDbCmd == PagingDbCmdEnum.Next)
                //    dbTableDml.AddOrderByColumnAscending(column);
                //else
                //    dbTableDml.AddOrderByColumnDescending(column);

                if (pagingDbCmd == PagingDbCmdEnum.Next || pagingDbCmd == PagingDbCmdEnum.Previous)
                {
                    expr = null;
                    exprAnd = null;

                    // Build AND clause for preceding columns
                    for (i = 0; i < columnIndex; i++)
                    {
                        expr = DbPredicate.CreatePredicatePart(tableName,
                            indexColumns[i], _daMgr.BuildParamName(indexColumns[i]), ComparisonOperatorEnum.Equals);

                        if (exprAnd == null)
                            exprAnd = expr;
                        else
                            exprAnd = Expression.AndAlso(exprAnd, expr);
                    }

                    // Build AND clause for current column
                    if (pagingDbCmd == PagingDbCmdEnum.Next)
                    {
                        expr = DbPredicate.CreatePredicatePart(tableName,
                                column, _daMgr.BuildParamName(column), ComparisonOperatorEnum.Greater);
                    }
                    else
                    {
                        expr = DbPredicate.CreatePredicatePart(tableName,
                                column, _daMgr.BuildParamName(column), ComparisonOperatorEnum.Less);
                    }

                    if (exprAnd == null)
                        exprAnd = expr;
                    else
                        exprAnd = Expression.AndAlso(exprAnd, expr);

                    // Append current expression group as OR clause into the WHERE condition
                    if (exprWhere == null)
                        exprWhere = exprAnd;
                    else
                        exprWhere = Expression.OrElse(exprWhere, exprAnd);
                }
            }

            return exprWhere;
            //if (exprWhere != null && dbTableDml._whereCondition == null)
            //    dbTableDml.SetWhereCondition(exprWhere);
            //else if (exprWhere != null)
            //    dbTableDml.AddToWhereCondition(ExpressionType.AndAlso, exprWhere);

            //return _daMgr.BuildSelectDbCommand(dbTableDml, _pageSizeParam);
        }

        DbCommand GetPageDbCmd( PagingDbCmdEnum pagingDbCmd
                , DbTableDmlMgr dbTableDmlSelect
                , List<string> indexColumns )
        {
            Int16 i;
            Int16 columnIndex;
            Expression expr;
            Expression exprAnd;
            Expression exprWhere = null;
            DbTableDmlMgr dbTableDml =  new DbTableDmlMgr(dbTableDmlSelect);
            dbTableDml.OrderByColumns.Clear();

            columnIndex = -1;
            foreach (string column in indexColumns)
            {
                columnIndex++;

                if (!_pageKeys.ContainsKey( column ))
                    _pageKeys.Add( column, column );

                if (pagingDbCmd == PagingDbCmdEnum.First
                        || pagingDbCmd == PagingDbCmdEnum.Next)
                    dbTableDml.AddOrderByColumnAscending(column);
                else
                    dbTableDml.AddOrderByColumnDescending(column);

                if (pagingDbCmd == PagingDbCmdEnum.Next || pagingDbCmd == PagingDbCmdEnum.Previous)
                {
                    expr = null;
                    exprAnd = null;

                    // Build AND clause for preceding columns
                    for (i = 0; i < columnIndex; i++)
                    {
                        expr = DbPredicate.CreatePredicatePart( dbTableDml.MainTable.TableName,
                            indexColumns[ i ], _daMgr.BuildParamName( indexColumns[ i ]), ComparisonOperatorEnum.Equals );

                        if (exprAnd == null)
                            exprAnd = expr;
                        else
                            exprAnd = Expression.AndAlso( exprAnd, expr );
                    }

                    // Build AND clause for current column
                    if (pagingDbCmd == PagingDbCmdEnum.Next)
                    {
                        expr = DbPredicate.CreatePredicatePart( dbTableDml.MainTable.TableName,
                                column, _daMgr.BuildParamName( column ), ComparisonOperatorEnum.Greater );
                    }
                    else
                    {
                        expr = DbPredicate.CreatePredicatePart( dbTableDml.MainTable.TableName,
                                column, _daMgr.BuildParamName( column ), ComparisonOperatorEnum.Less );
                    }

                    if (exprAnd == null)
                        exprAnd = expr;
                    else
                        exprAnd = Expression.AndAlso( exprAnd, expr );

                    // Append current expression group as OR clause into the WHERE condition
                    if (exprWhere == null)
                        exprWhere = exprAnd;
                    else
                        exprWhere = Expression.OrElse( exprWhere, exprAnd );
                }
            }

            if (exprWhere != null && dbTableDml._whereCondition == null)
                dbTableDml.SetWhereCondition( exprWhere );
            else if(exprWhere != null)
                dbTableDml.AddToWhereCondition(ExpressionType.AndAlso, exprWhere );

            return _daMgr.BuildSelectDbCommand( dbTableDml, _pageSizeParam );
        }


        void Initialize(DbCommand dbCmdFirstPage
                , DbCommand dbCmdLastPage
                , DbCommand dbCmdNextPage
                , DbCommand dbCmdPreviousPage)
        {
            _dbCmdFirstPage = dbCmdFirstPage;
            _dbCmdLastPage = dbCmdLastPage;
            _dbCmdPreviousPage = dbCmdPreviousPage;
            _dbCmdNextPage = dbCmdNextPage;
        }


        DataTable ProcessNewPage(DataTable newPage)
        {
            if (newPage != null
                && newPage.Rows.Count > 0)
            {
                // set the pageItem keys
                SetKeyItemValues(_pageFirstItem, newPage.Rows[0]);
                SetKeyItemValues(_pageLastItem, newPage.Rows[newPage.Rows.Count - 1]);
            }
            return newPage;
        }

        void SetKeyItemValues(Dictionary<string, object> pageItem, DataRow itemRow)
        {
            foreach (string pageKey in _pageKeys.Keys)
                pageItem[pageKey] = itemRow[pageKey];
        }

        void SetKeyItemValues(Dictionary<string, object> pageItem, Dictionary<string, PropertyInfo> propertyDic,
                object rowObject)
        {
            foreach (string pageKey in _pageKeys.Keys)
                pageItem[pageKey] = propertyDic[pageKey].GetValue(rowObject, null);
        }

        void SetKeyItemValues(Dictionary<string, object> pageItem, object rowObject)
        {
            var propertyDic = rowObject.GetType().GetProperties().ToDictionary(kv => kv.Name, kv => kv, 
                    StringComparer.CurrentCultureIgnoreCase);

            SetKeyItemValues(pageItem, propertyDic, rowObject);
        }

        public DataTable GetPage(PagingDbCmdEnum pagingDirection, Int16? pageSize = null)
        {
            switch (pagingDirection)
            {
                case PagingDbCmdEnum.First:
                    return pageSize == null ? GetFirstPage() : GetFirstPage(pageSize.Value);
                case PagingDbCmdEnum.Next:
                    return pageSize == null ? GetNextPage() : GetNextPage(pageSize.Value);
                case PagingDbCmdEnum.Previous:
                    return pageSize == null ? GetPreviousPage() : GetPreviousPage(pageSize.Value);
                case PagingDbCmdEnum.Last:
                    return pageSize == null ? GetLastPage() : GetLastPage(pageSize.Value);
            }

            return null;
        }

        public IEnumerable<T> GetPage<T>(PagingDbCmdEnum pagingDirection, Int16? pageSize = null) where T : new()
        {
            switch (pagingDirection)
            {
                case PagingDbCmdEnum.First:
                    return pageSize == null ? GetFirstPage<T>() : GetFirstPage<T>(pageSize.Value);
                case PagingDbCmdEnum.Next:
                    return pageSize == null ? GetNextPage<T>() : GetNextPage<T>(pageSize.Value);
                case PagingDbCmdEnum.Previous:
                    return pageSize == null ? GetPreviousPage<T>() : GetPreviousPage<T>(pageSize.Value);
                case PagingDbCmdEnum.Last:
                    return pageSize == null ? GetLastPage<T>() : GetLastPage<T>(pageSize.Value);
            }

            return null;
        }

        /// <summary>
        /// Returns the page size value for being used
        /// </summary>
        public Int16 PageSize
        {
            get { return _pageSize; }
        }

        /// <summary>
        /// Returns the first pagesize buffer of data
        /// </summary>
        /// <param name="pageSize">The size of the buffer to return. Must be greater than 0 or default will be used</param>
        /// <returns>First buffer of data</returns>
        public DataTable GetFirstPage(Int16 pageSize)
        {
            // set parameter values
            _dbCmdFirstPage.Parameters[_daMgr.BuildParamName(_pageSizeParam)].Value = pageSize > 0 ? pageSize : _pageSize;
            return ProcessNewPage(_daMgr.ExecuteDataSet(_dbCmdFirstPage, null, null).Tables[0]);
        }

        /// <summary>
        /// Returns the first pagesize buffer of data
        /// </summary>
        /// <param name="pageSize">The size of the buffer to return. Must be greater than 0 or default will be used</param>
        /// <returns>First buffer of data</returns>
        public IEnumerable<T> GetFirstPage<T>(Int16 pageSize) where T : new()
        {
            // set parameter values
            _dbCmdFirstPage.Parameters[_daMgr.BuildParamName(_pageSizeParam)].Value = pageSize > 0 ? pageSize : _pageSize;
            return _daMgr.ExecuteCollection<T>(_dbCmdFirstPage, null, GetCollectionAndProcess<T>, null);
        }

        /// <summary>
        /// Returns the first pagesize buffer of data
        /// </summary>
        /// <returns>First buffer of data</returns>
        public DataTable GetFirstPage()
        {
            return GetFirstPage(_pageSize);
        }

        /// <summary>
        /// Returns the first pagesize buffer of data
        /// </summary>
        /// <returns>First buffer of data</returns>
        public IEnumerable<T> GetFirstPage<T>() where T : new()
        {
            return GetFirstPage<T>(_pageSize);
        }

        /// <summary>
        /// Returns the last pagesize buffer of data
        /// </summary>
        /// <param name="pageSize"></param>
        /// <returns>last buffer of data</returns>
        public DataTable GetLastPage(Int16 pageSize)
        {
            // set parameter values
            _dbCmdLastPage.Parameters[_daMgr.BuildParamName(_pageSizeParam)].Value = pageSize > 0 ? pageSize : _pageSize;
            return ProcessNewPage(_daMgr.ExecuteReader(_dbCmdLastPage, null, GetReverseOrderDataTable));
        }

        /// <summary>
        /// Returns the last pagesize buffer of data
        /// </summary>
        /// <param name="pageSize"></param>
        /// <returns>last buffer of data</returns>
        public IEnumerable<T> GetLastPage<T>(Int16 pageSize) where T : new()
        {
            // set parameter values
            _dbCmdLastPage.Parameters[_daMgr.BuildParamName(_pageSizeParam)].Value = pageSize > 0 ? pageSize : _pageSize;
            return _daMgr.ExecuteCollection<T>(_dbCmdLastPage, null, ReverseCollectionAndProcess<T>);
        }

        /// <summary>
        /// Returns the last pagesize buffer of data
        /// </summary>
        /// <returns>Last buffer of data</returns>
        public DataTable GetLastPage()
        {
            return GetLastPage(_pageSize);
        }

        
        /// <summary>
        /// Returns the last pagesize buffer of data
        /// </summary>
        /// <returns>last buffer of data</returns>
        public IEnumerable<T> GetLastPage<T>() where T : new()
        {
            return GetLastPage<T>(_pageSize);
        }

        /// <summary>
        /// Returns the next pagesize buffer of data given the values found for the
        /// keys of the last row of the current buffer as maintained by caller.
        /// </summary>
        /// <param name="lastRow">The last datarow of the current buffer</param>
        /// <param name="pageSize">The size of the buffer to return</param>
        /// <returns>Next buffer of data</returns>
        public DataTable GetNextPage(DataRow lastRow, Int16 pageSize)
        {
            SetKeyItemValues(_pageLastItem, lastRow);
            return GetNextPage(_pageLastItem, pageSize);
        }

        /// <summary>
        /// Returns the next pagesize buffer of data given the values found for the
        /// keys of the last row of the current buffer as maintained by caller.
        /// </summary>
        /// <param name="lastObject">The last object in the current collection.</param>
        /// <param name="pageSize">The size of the buffer to return</param>
        /// <returns>Next buffer of data</returns>
        public IEnumerable<T> GetNextPage<T>(T lastObject, Int16 pageSize) where T : new()
        {
            // set parameter values
            SetKeyItemValues(_pageLastItem, lastObject);
            return GetNextPage<T>(_pageLastItem, pageSize);
        }

        /// <summary>
        /// Returns the next pagesize buffer of data given the values found for the
        /// keys of the last collection of the current buffer as maintained by caller.
        /// </summary>
        /// <param name="pageLastItem">A collection containing the keys and the values 
        /// for the last item of the most recent page retrieved.</param>
        /// <param name="pageSize">The size of the buffer to return</param>
        /// <returns>Next buffer of data</returns>
        public DataTable GetNextPage(Dictionary<string, object> pageLastItem, Int16 pageSize)
        {
            if (_pageLastItem != null && _pageLastItem.Count > 0)
            {
                foreach (string pageKey in _pageKeys.Keys)
                    _dbCmdNextPage.Parameters[_daMgr.BuildParamName(pageKey)].Value = pageLastItem[pageKey];
                _dbCmdNextPage.Parameters[_daMgr.BuildParamName(_pageSizeParam)].Value = pageSize > 0 ? pageSize : _pageSize;
                return ProcessNewPage(_daMgr.ExecuteDataSet(_dbCmdNextPage, null, null).Tables[0]);
            }
            else return GetFirstPage(pageSize);
        }

        /// <summary>
        /// Returns the next pagesize buffer of data given the values found for the
        /// keys of the last collection of the current buffer as maintained by caller.
        /// </summary>
        /// <param name="pageLastItem">A collection containing the keys and the values 
        /// for the last item of the most recent page retrieved.</param>
        /// <param name="pageSize">The size of the buffer to return</param>
        /// <returns>Next buffer of data</returns>
        public IEnumerable<T> GetNextPage<T>(Dictionary<string, object> pageLastItem, Int16 pageSize) where T : new()
        {
            if (_pageLastItem != null && _pageLastItem.Count > 0)
            {
                foreach (string pageKey in _pageKeys.Keys)
                    _dbCmdNextPage.Parameters[_daMgr.BuildParamName(pageKey)].Value = pageLastItem[pageKey];
                _dbCmdNextPage.Parameters[_daMgr.BuildParamName(_pageSizeParam)].Value = pageSize > 0 ? pageSize : _pageSize;
                return _daMgr.ExecuteCollection<T>(_dbCmdNextPage, null, GetCollectionAndProcess<T>, null);
            }
            else return GetFirstPage<T>(pageSize);
        }

        /// <summary>
        /// Returns the next pagesize buffer of data given the values found for the
        /// keys of the last row of the current buffer.
        /// </summary>
        /// <param name="pageSize">The size of the buffer to return</param>
        /// <returns>Next buffer of data</returns>
        public DataTable GetNextPage(Int16 pageSize)
        {
            return GetNextPage(_pageLastItem, pageSize);
        }

        /// <summary>
        /// Returns the next pagesize buffer of data given the values found for the
        /// keys of the last row of the current buffer and the current page size.
        /// </summary>
        /// <returns>Next buffer of data</returns>
        public DataTable GetNextPage()
        {
            return GetNextPage(_pageLastItem, _pageSize);
        }

        /// <summary>
        /// Returns the next pagesize buffer of data given the values found for the
        /// keys of the last row of the current buffer.
        /// </summary>
        /// <param name="pageSize">The size of the buffer to return</param>
        /// <returns>Next buffer of data</returns>
        public IEnumerable<T> GetNextPage<T>(Int16 pageSize) where T : new()
        {
            return GetNextPage<T>(_pageLastItem, pageSize);
        }

        /// <summary>
        /// Returns the next pagesize buffer of data given the values found for the
        /// keys of the last row of the current buffer and the current page size.
        /// </summary>
        /// <returns>Next buffer of data</returns>
        public IEnumerable<T> GetNextPage<T>() where T : new()
        {
            return GetNextPage<T>(_pageLastItem, _pageSize);
        }

        /// <summary>
        /// Returns the previous pagesize buffer of data given the values found for the
        /// keys of the first row of the current buffer as maintained by caller.
        /// </summary>
        /// <param name="firstRow">The first datarow of the current buffer</param>
        /// <param name="pageSize">The size of the buffer to return</param>
        /// <returns>Previous buffer of data</returns>
        public DataTable GetPreviousPage(DataRow firstRow, Int16 pageSize)
        {
            SetKeyItemValues(_pageFirstItem, firstRow);
            return GetPreviousPage(_pageFirstItem, pageSize);
        }

        /// <summary>
        /// Returns the previous pagesize buffer of data given the values found for the
        /// keys of the first row of the current buffer as maintained by caller.
        /// </summary>
        /// <param name="firstObject">The first object in the current collection</param>
        /// <param name="pageSize">The size of the buffer to return</param>
        /// <returns>Previous buffer of data</returns>
        public IEnumerable<T> GetPreviousPage<T>(T firstObject, Int16 pageSize) where T : new()
        {
            SetKeyItemValues(_pageFirstItem, firstObject);
            return GetPreviousPage<T>(_pageFirstItem, pageSize);
        }

        /// <summary>
        /// Returns the previous pagesize buffer of data given the values found for the
        /// keys of the first collection of the current buffer as maintained by caller.
        /// </summary>
        /// <param name="pageFirstItem">A collection containing the keys and the values 
        /// for the first item of the most recent page retrieved.</param>
        /// <param name="pageSize">The size of the buffer to return</param>
        /// <returns>Previous buffer of data</returns>
        public DataTable GetPreviousPage(Dictionary<string, object> pageFirstItem, Int16 pageSize)
        {
            if (_pageFirstItem != null && _pageFirstItem.Count > 0)
            {
                foreach (string pageKey in _pageKeys.Keys)
                    _dbCmdPreviousPage.Parameters[_daMgr.BuildParamName(pageKey)].Value = pageFirstItem[pageKey];
                _dbCmdPreviousPage.Parameters[_daMgr.BuildParamName(_pageSizeParam)].Value
                        = pageSize > 0 ? pageSize : _pageSize;
                return ProcessNewPage(_daMgr.ExecuteReader(_dbCmdPreviousPage, null, GetReverseOrderDataTable));
            }
            else return GetLastPage(pageSize);
        }

        /// <summary>
        /// Returns the previous pagesize buffer of data given the values found for the
        /// keys of the first collection of the current buffer as maintained by caller.
        /// </summary>
        /// <param name="pageFirstItem">A collection containing the keys and the values 
        /// for the first item of the most recent page retrieved.</param>
        /// <param name="pageSize">The size of the buffer to return</param>
        /// <returns>Previous buffer of data</returns>
        public IEnumerable<T> GetPreviousPage<T>(Dictionary<string, object> pageFirstItem, Int16 pageSize) where T : new()
        {
            if (_pageFirstItem != null && _pageFirstItem.Count > 0)
            {
                foreach (string pageKey in _pageKeys.Keys)
                    _dbCmdPreviousPage.Parameters[_daMgr.BuildParamName(pageKey)].Value = pageFirstItem[pageKey];
                _dbCmdPreviousPage.Parameters[_daMgr.BuildParamName(_pageSizeParam)].Value
                        = pageSize > 0 ? pageSize : _pageSize;
                return _daMgr.ExecuteCollection<T>(_dbCmdPreviousPage, null, ReverseCollectionAndProcess<T>);
            }
            else return GetLastPage<T>(pageSize);
        }

        /// <summary>
        /// Returns the previous pagesize buffer of data given the values found for the
        /// keys of the first row of the current buffer.
        /// </summary>
        /// <param name="pageSize">The size of the buffer to return</param>
        /// <returns>Previous buffer of data</returns>
        public DataTable GetPreviousPage(Int16 pageSize)
        {
            return GetPreviousPage(_pageFirstItem, pageSize);
        }

        /// <summary>
        /// Returns the previous pagesize buffer of data given the values found for the
        /// keys of the first row of the current buffer and the current page szie.
        /// </summary>
        /// <returns>Previous buffer of data</returns>
        public IEnumerable<T> GetPreviousPage<T>() where T : new()
        {
            return GetPreviousPage<T>(_pageFirstItem, _pageSize);
        }

        /// <summary>
        /// Returns the previous pagesize buffer of data given the values found for the
        /// keys of the first row of the current buffer.
        /// </summary>
        /// <param name="pageSize">The size of the buffer to return</param>
        /// <returns>Previous buffer of data</returns>
        public IEnumerable<T> GetPreviousPage<T>(Int16 pageSize) where T : new()
        {
            return GetPreviousPage<T>(_pageFirstItem, pageSize);
        }

        /// <summary>
        /// Returns the previous pagesize buffer of data given the values found for the
        /// keys of the first row of the current buffer and the current page szie.
        /// </summary>
        /// <returns>Previous buffer of data</returns>
        public DataTable GetPreviousPage()
        {
            return GetPreviousPage(_pageFirstItem, _pageSize);
        }

        /// <summary>
        /// Generates a string representing the paging state
        /// </summary>
        /// <returns></returns>
        public string GetPagingState()
        {
            var stateArray = new Dictionary<string,object>[] { _pageFirstItem, _pageLastItem };
            DataContractJsonSerializer serializer = new DataContractJsonSerializer(typeof(Dictionary<string,object>[]));
            
            using(MemoryStream ms = new MemoryStream())
            {
                serializer.WriteObject(ms, stateArray);
                return Convert.ToBase64String(ms.ToArray());
            }
        }

        /// <summary>
        /// Restores the paging state of this instance from the paging state string generated by
        /// calling GetPagingState()
        /// </summary>
        /// <param name="pagingState">paging state string generated by calling GetPagingState()</param>
        public void RestorePagingState(string pagingState)
        {
            if(string.IsNullOrWhiteSpace(pagingState))
                return;

            DataContractJsonSerializer serializer = new DataContractJsonSerializer(typeof(Dictionary<string,object>[]));
            
            using(MemoryStream ms = new MemoryStream(Convert.FromBase64String(pagingState)))
            {
                Dictionary<string,object>[] stateArray = (Dictionary<string,object>[])serializer.ReadObject(ms);
   
                _pageFirstItem = stateArray[0];
                _pageLastItem = stateArray[1];
            }
        }
        /// <summary>
        /// Populates a DataTable with the contents of a dataReader by inserting
        /// each new row at the top of the DataTable (position 0) so that the results
        /// will appear in the reverse order as they were returned.  This was necessary
        /// for backward paging where the result set is in descending order.
        /// </summary>
        /// <param name="dataReader">Open DataReader</param>
        /// <returns>DataTable with data and schema from dataReader</returns>
        DataTable GetReverseOrderDataTable(IDataReader dataReader)
        {
            DataTable dt = GetEmptyTableFromDataReader(dataReader);
            while (dataReader.Read())
            {
                object[] vals = new object[dt.Columns.Count];
                dataReader.GetValues(vals);
                DataRow dr = dt.NewRow();
                dr.ItemArray = vals;
                dt.Rows.InsertAt(dr, 0);
            }
            return dt;
        }

        /// Populates a List with the contents of a dataReader by inserting
        /// each new type T at the top of the collection (position 0) so that the results
        /// will appear in the reverse order as they were returned.  This was necessary
        /// for backward paging where the result set is in descending order.
        /// Last item and first item key values will be stored based on first and last object.
        IEnumerable<T> ReverseCollectionAndProcess<T>(IDataReader rdr, 
                List<KeyValuePair<int, PropertyInfo>> properties) where T : new()
        {
            List<T> items = new List<T>();
            
            while (rdr.Read())
            {
                T obj = new T();

                properties.ForEach(kv => kv.Value.SetValue(obj, DataAccessMgr.GetValueOrNull(
                        Convert.ChangeType(rdr.GetValue(kv.Key), kv.Value.PropertyType)), null));
                items.Insert(0, obj);
            }

            if(items.Count > 0)
            {
                Dictionary<string, PropertyInfo> propertyDic = properties.ToDictionary(kv => kv.Value.Name, kv => kv.Value,
                        StringComparer.CurrentCultureIgnoreCase);

                SetKeyItemValues(_pageFirstItem, propertyDic, items.First());
                SetKeyItemValues(_pageLastItem, propertyDic, items.Last());
            }

            return items;
        }

        /// Populates a List with the contents of a dataReader in the order read.
        /// Last item and first item key values will be stored based on first and last object.
        IEnumerable<T> GetCollectionAndProcess<T>(IDataReader rdr, 
                List<KeyValuePair<int, PropertyInfo>> properties) where T : new()
        {
            List<T> items = new List<T>();
            
            while (rdr.Read())
            {
                T obj = new T();

                properties.ForEach(kv => kv.Value.SetValue(obj, DataAccessMgr.GetValueOrNull(
                        Convert.ChangeType(rdr.GetValue(kv.Key), kv.Value.PropertyType)), null));
                items.Add(obj);
            }

            if(items.Count > 0)
            {
                Dictionary<string, PropertyInfo> propertyDic = properties.ToDictionary(kv => kv.Value.Name, kv => kv.Value,
                    StringComparer.CurrentCultureIgnoreCase);

                SetKeyItemValues(_pageFirstItem, propertyDic, items.First());
                SetKeyItemValues(_pageLastItem, propertyDic, items.Last());
            }

            return items;
        }

        /// <summary>
        /// Returns an empty data table with schema defined from the dataReader
        /// </summary>
        /// <param name="dataReader">Open data reader</param>
        /// <returns>Empty data table with schema defined</returns>
        DataTable GetEmptyTableFromDataReader(IDataReader dataReader)
		{	
			DataTable dt = new DataTable();
            if (dataReader != null)
                for (int i = 0; i < dataReader.FieldCount; ++i)
                    dt.Columns.Add(dataReader.GetName(i), dataReader.GetFieldType(i));
			return dt;
		}

    }
}
